<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="public, max-age=31536000">
    <title>Crazy Aces - Playing Arts</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        html {
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            height: 100vh;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            padding: 20px;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        .game-container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        .game-container.loaded {
            opacity: 1;
            overflow: visible;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-logo {
            width: 128px;
            height: 26px;
            margin-bottom: 30px;
            opacity: 0.3;
        }

        .loading-text {
            font-size: 15px;
            color: rgba(255, 255, 255, 0.9);
            opacity: 0.5;
        }

        .rules-logo {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 128px;
            height: 26px;
            color: #4c4c4c;
            opacity: 1;
            z-index: 1001;
        }

        .rules-box {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .rules-box.hidden {
            opacity: 0;
            transform: translateX(100%);
            pointer-events: none;
        }

        .rules-logo svg {
            width: 100%;
            height: 100%;
        }

        .rules-content {
            color: rgba(255,255,255,0.5);
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .rules-content h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 0 0 8px 0;
            color: rgba(255,255,255,0.5);
        }

        .rules-content ul {
            margin: 0;
            padding-left: 18px;
        }

        .rules-content li {
            margin-bottom: 4px;
        }

        .rules-ok-btn {
            background: #4c4c4c;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            padding: 8px 28px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            width: auto;
            display: block;
            float: left;
            transition: all 0.3s ease;
        }

        .rules-ok-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 76, 76, 0.4);
        }

        @keyframes cardPlayedFromHand {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-150px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes cardPlayedFromOpponent {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(150px) scale(0.8);
                opacity: 0;
            }
        }

        .card-flying-out {
            animation: cardPlayedFromHand 0.25s ease forwards;
            pointer-events: none;
            /* Hardware acceleration for smoother mobile performance */
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        .card-flying-out-opponent {
            animation: cardPlayedFromOpponent 0.25s ease forwards;
            /* Hardware acceleration for smoother mobile performance */
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        @keyframes hintShake {
            0%, 100% { transform: rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: rotate(-5deg); }
            20%, 40%, 60%, 80% { transform: rotate(5deg); }
        }

        .hint-shake {
            animation: hintShake 0.6s ease-in-out !important;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
        }

        .player-name {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
        }

        .opponent-hand-section {
            min-height: 110px;
            display: flex;
            justify-content: center;
        }

        .opponent-hand-preview {
            display: inline-flex;
            gap: 8px;
            justify-content: center;
            padding: 13px;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            min-height: 80px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card-back-small {
            width: 45px;
            height: 65px;
            background: #4c4c4c;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            opacity: 0.5;
        }

        .card-back-small::after {
            content: '?';
            font-size: 32px;
            font-weight: bold;
            color: #666;
        }

        .play-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            padding: 0 40px;
            min-height: 350px;
            padding-bottom: 29px;
        }

        .deck-pile {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .deck-pile::before,
        .deck-pile::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: #6a6a6a;
            border-radius: 12px;
            z-index: -1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            top: 0;
            left: 0;
        }

        .deck-pile::before {
            transform: rotate(-2deg);
        }

        .deck-pile::after {
            transform: rotate(3deg);
        }

        .deck-pile:hover {
            transform: translateY(-5px);
        }

        @keyframes deckDraw {
            0%, 100% {
                transform: scale(1);
            }
            25% {
                transform: scale(0.95);
            }
            50% {
                transform: scale(1.02);
            }
            75% {
                transform: scale(0.98);
            }
        }

        .deck-pile.deck-drawing {
            animation: deckDraw 0.4s ease;
        }

        .card {
            width: 210px;
            height: 300px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: inherit;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 12px;
            z-index: 1;
            pointer-events: none;
        }

        .card.wild-card-played {
            animation: wildCardGlow 1s ease-out;
        }

        @keyframes wildCardGlow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 40px rgba(255,215,0,0.8), 0 0 80px rgba(255,215,0,0.5);
            }
        }

        .card-back {
            background-image: url('https://s3.amazonaws.com/img.playingarts.com/one-small-hd/_backside-evgeny-kiselev.jpg?2');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            overflow: hidden;
        }

        .discard-pile {
            position: relative;
        }

        .card-stack {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        @keyframes cardDropFromTop {
            0% {
                transform: translateY(-100px) translateX(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateY(0) translateX(0) rotate(var(--rotation));
                opacity: 1;
            }
        }

        @keyframes cardDropFromBottom {
            0% {
                transform: translateY(100px) translateX(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateY(0) translateX(0) rotate(var(--rotation));
                opacity: 1;
            }
        }

        .card.card-animating-from-top {
            animation: cardDropFromTop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .card.card-animating-from-bottom {
            animation: cardDropFromBottom 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .card .card-rank {
            display: none;
        }

        .card .card-suit {
            display: none;
        }

        .card-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 24px;
            color: rgba(255,255,255,0.8);
            white-space: nowrap;
            z-index: 0;
        }

        .card-info .info-rank {
            font-weight: bold;
            font-size: 48px;
        }

        .card-info .info-suit {
            font-size: 52px;
        }

        .card-info .info-joker {
            font-weight: bold;
            font-size: 20px;
            color: #FFD700;
        }

        .card.spades { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 3px solid #667eea; }
        .card.hearts { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border: 3px solid #f093fb; }
        .card.diamonds { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border: 3px solid #4facfe; }
        .card.clubs { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border: 3px solid #43e97b; }
        .card.joker { background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); border: 3px solid #FFD700; }

        .card-rank {
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: absolute;
            top: 15px;
            left: 15px;
        }

        .card-suit {
            font-size: 84px;
            filter: brightness(0) invert(1);
        }

        .card-artist {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 15px;
            padding: 0;
            background: none;
            border-radius: 0;
            white-space: nowrap;
            opacity: 0.5;
            transition: opacity 0.3s ease;
            z-index: 2;
        }

        .card-artist a {
            color: rgba(255,255,255,0.9);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .card-artist:hover {
            opacity: 1;
        }

        .card-artist a:hover {
            color: rgba(255,255,255,1);
        }

        .player-hand-section {
            min-height: 135px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: visible;
        }

        .player-hand {
            background: #f5f5f5;
            border-radius: 20px;
            padding: 13px 7px 13px 13px;
            display: inline-block;
            margin: 0 auto;
            overflow: visible;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hand-cards {
            display: flex;
            justify-content: center;
            flex-wrap: nowrap;
            overflow: visible;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hand-card {
            width: 60px;
            height: 87px;
            border-radius: 8px;
            cursor: grab;
            margin-right: 7px;
            transition: width 0.3s ease, margin 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #1a1a1a;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .hand-card.ace-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .hand-card.joker-card {
            background: linear-gradient(270deg, #FFD700, #FFA500, #FF6347, #FFA500, #FFD700);
            background-size: 400% 400%;
            animation: jokerGlow 6s ease infinite;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.6);
        }

        @keyframes jokerGlow {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .hand-card:active {
            cursor: grabbing;
        }

        .hand-card[draggable="true"]:hover {
            transform: translateY(-5px);
        }

        .discard-pile {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .discard-pile.drag-over {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        }

        .hand-card .card-rank {
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: none;
            position: static;
            line-height: 1;
            text-align: center;
        }

        .hand-card .card-suit {
            font-size: 25px;
            filter: brightness(0) invert(1);
            margin-top: 5px;
            line-height: 1;
            text-align: center;
        }

        .joker-text {
            font-size: 12px !important;
            font-weight: 700;
        }

        /* Hide logo and rules on mobile */
        @media (max-width: 767px) {
            html {
                height: 100vh;
                height: -webkit-fill-available;
            }

            body {
                padding: 0;
                height: 100vh;
                height: -webkit-fill-available;
            }

            .game-container {
                height: 100vh;
                height: -webkit-fill-available;
                max-height: 100vh;
                gap: 0;
                padding: 0;
                overflow: hidden;
            }

            .rules-logo,
            .rules-box {
                display: none;
            }

            .opponent-hand-section {
                min-height: 70px;
                height: 70px;
                align-items: center;
                padding: 4px 0;
            }

            .opponent-hand-preview {
                padding: 6px;
                min-height: 60px;
            }

            .player-hand-section {
                min-height: 110px;
                margin-bottom: 0;
                padding-bottom: 0;
            }

            .player-hand {
                margin-bottom: 0;
            }
        }

        @media (min-width: 768px) {
            .card {
                width: 225px;
                height: 322px;
            }

            .card .card-rank {
                font-size: 78px;
            }

            .card .card-suit {
                font-size: 90px;
            }

            .play-area {
                gap: 35px;
                padding: 0 45px;
                min-height: 420px;
                padding-bottom: 60px;
            }

            .opponent-hand-preview {
                padding: 13px;
                min-height: 90px;
            }

            .card-back-small {
                width: 50px;
                height: 72px;
            }

            .card-back-small::after {
                font-size: 36px;
            }

            body {
                align-items: flex-start;
                padding-top: 20px;
            }

            .game-container {
                justify-content: flex-start;
            }

            .player-hand-section {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                min-height: 135px;
                background: transparent;
                z-index: 100;
            }
        }

        @media (min-width: 1200px) {
            .card {
                width: 255px;
                height: 365px;
            }
            
            .card .card-rank {
                font-size: 87px;
            }
            
            .card .card-suit {
                font-size: 102px;
            }
            
            .play-area {
                gap: 40px;
                padding: 0 50px;
                min-height: 480px;
                padding-bottom: 60px;
            }
            
            .opponent-hand-preview {
                padding: 13px;
                min-height: 95px;
            }
            
            .card-back-small {
                width: 54px;
                height: 78px;
            }

            .card-back-small::after {
                font-size: 38px;
            }
        }

        .hand-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }

        .status-message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-size: 15px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .suit-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.98);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            z-index: 1000;
            display: none;
        }

        .suit-selector.show {
            display: block;
        }

        .suit-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .suit-selector-title {
            font-size: 18px;
            color: rgba(255,255,255,0.9);
            flex: 1;
            text-align: center;
        }

        .close-selector-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .close-selector-btn:hover {
            background: rgba(255,255,255,0.2);
            color: rgba(255,255,255,1);
            transform: scale(1.1);
        }

        .suit-options {
            display: flex;
            gap: 20px;
        }

        .suit-option {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .suit-option:hover {
            transform: scale(1.1);
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.1);
        }

        .suit-option.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        .suit-option.disabled:hover {
            transform: none;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,20,0.98);
            padding: 50px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .game-over.show {
            display: block;
        }

        .result-text {
            font-size: 42px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .result-text.win {
            color: #43e97b;
        }

        .result-text.lose {
            color: #f5576c;
        }

        .play-again-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 20px 60px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s ease;
            margin-top: 30px;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .play-again-btn:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            transform: scale(1.08);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.6);
        }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f0f;
            animation: confetti-fall linear forwards;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* Mobile styles */
        @media (max-width: 480px) {
            body {
                padding: 8px;
                align-items: flex-start;
                min-height: 100vh;
                max-height: 100vh;
                overflow-x: visible;
                overflow-y: hidden;
            }

            body > * {
                overflow: visible;
            }

            .game-container {
                gap: 23px;
                overflow: visible;
                padding-bottom: 0;
            }

            .game-container > div {
                overflow: visible;
            }

            .top-bar {
                padding: 15px 18px;
            }

            .player-name {
                font-size: 11px;
            }

            .opponent-hand-preview {
                padding: 10px;
                gap: 8px;
                min-height: auto;
            }

            .card-back-small {
                width: 32px;
                height: 46px;
            }

            .card-back-small::after {
                font-size: 24px;
            }

            .status-message {
                font-size: 13px;
                padding: 8px 12px;
                min-height: 40px;
                white-space: pre-line;
                line-height: 1.4;
            }

            .card-artist {
                font-size: 13px;
            }

            .card {
                width: 168px;
                height: 240px;
            }

            .card .card-rank {
                font-size: 38px;
            }

            .card .card-suit {
                font-size: 45px;
            }

            .play-area {
                gap: 22px;
                padding: 10px 8px;
                min-height: 250px;
                flex: 0 1 auto;
            }

            .hand-card {
                width: 45px;
                height: 65px;
                flex-shrink: 0;
                min-width: 45px;
                position: relative;
                z-index: 1;
                -webkit-tap-highlight-color: transparent;
                margin-right: 4px; /* Reduced spacing on mobile */
            }

            .hand-card:not(.hint-shake) {
                transform: translateY(0) scale(1) !important;
                transition: transform 0.2s ease-in-out !important;
            }

            .hand-card:hover:not(.hint-shake) {
                transform: translateY(0) scale(1) !important;
            }

            .hand-card:active:not(.hint-shake) {
                transform: translateY(-12px) scale(1.08) !important;
                z-index: 10;
                transition: transform 0.1s ease-out !important;
            }

            .hand-card .card-rank {
                font-size: 18px;
            }

            .hand-card .card-suit {
                font-size: 16px;
                margin-top: 3px;
            }

            .joker-text {
                font-size: 7px;
            }

            .hand-cards {
                padding: 15px 4px; /* Reduced horizontal padding */
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                margin-top: -15px;
                margin-bottom: -15px;
                clip-path: none;
            }

            .hand-cards::-webkit-scrollbar {
                height: 3px;
            }

            .hand-cards::-webkit-scrollbar-track {
                background: rgba(255,255,255,0.05);
                border-radius: 2px;
            }

            .hand-cards::-webkit-scrollbar-thumb {
                background: rgba(255,255,255,0.2);
                border-radius: 2px;
            }

            .game-container > div:last-child {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 100;
                transition: opacity 0.25s ease;
            }

            .player-hand {
                padding: 10px 2px 10px 6px;
                max-width: 100%;
                overflow: visible;
                border-radius: 15px;
            }

            .suit-selector {
                padding: 25px;
                max-width: 90%;
            }

            .suit-selector-title {
                font-size: 13px;
            }

            .suit-options {
                gap: 12px;
            }

            .suit-option {
                width: 60px;
                height: 60px;
                font-size: 29px;
            }

            .game-over {
                padding: 40px 20px;
                max-width: 95%;
                width: 95%;
            }

            .result-text {
                font-size: 32px;
                margin-bottom: 8px;
            }

            .play-again-btn {
                padding: 20px 60px;
                font-size: 20px;
                margin-top: 8px;
                margin-bottom: 40px;
            }
        }

    </style>
    
    <!-- Preload card back for immediate availability -->
    <link rel="preload" as="image" href="https://s3.amazonaws.com/img.playingarts.com/one-small-hd/_backside-evgeny-kiselev.jpg?2" crossorigin="anonymous" fetchpriority="high">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <svg class="loading-logo" width="128" height="26" viewBox="0 0 128 26" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M114.633 21.0497L106.583 13L114.633 4.95038L122.682 13L114.633 21.0497ZM113.345 1.08811L102.721 11.7126C102.01 12.4236 102.01 13.5764 102.721 14.2874L113.345 24.9119C114.056 25.6229 115.209 25.6229 115.92 24.9119L126.545 14.2874C127.256 13.5764 127.256 12.4236 126.545 11.7126L115.92 1.08811C115.209 0.377085 114.056 0.377083 113.345 1.08811ZM80.6667 12.0667C83.7595 12.0667 86.2667 9.55947 86.2667 6.46668C86.2667 3.37388 83.7595 0.866679 80.6667 0.866679C77.5739 0.866679 75.0667 3.37388 75.0667 6.46668C75.0667 9.55947 77.5739 12.0667 80.6667 12.0667ZM88.1333 25.1333C91.2261 25.1333 93.7333 22.6261 93.7333 19.5333C93.7333 16.4406 91.2261 13.9333 88.1333 13.9333C85.0405 13.9333 82.5333 16.4406 82.5333 19.5333C82.5333 22.6261 85.0405 25.1333 88.1333 25.1333ZM78.8 19.5333C78.8 22.6261 76.2928 25.1333 73.2 25.1333C70.1072 25.1333 67.6 22.6261 67.6 19.5333C67.6 16.4406 70.1072 13.9333 73.2 13.9333C76.2928 13.9333 78.8 16.4406 78.8 19.5333ZM53.8945 5.65178L46.8334 18.4031L39.7724 5.65178L53.8945 5.65178ZM48.4464 23.2323C47.7319 24.5226 45.9349 24.5226 45.2204 23.2323L34.9493 4.68404C34.2383 3.40013 35.1333 1.80001 36.5623 1.80001L57.1045 1.80001C58.5336 1.80001 59.4285 3.40013 58.7175 4.68405L48.4464 23.2323ZM5.93897 20.3483L13 7.59693L20.0611 20.3483H5.93897ZM11.387 2.76775C12.1015 1.47744 13.8985 1.47744 14.613 2.76775L24.8841 21.316C25.5951 22.5999 24.7002 24.2 23.2711 24.2H2.72892C1.29988 24.2 0.404947 22.5999 1.11592 21.316L11.387 2.76775Z" style="transition:opacity 1s;opacity:1"></path>
            <path fill-rule="evenodd" clip-rule="evenodd" fill="url(#color)" d="M114.633 21.0497L106.583 13L114.633 4.95038L122.682 13L114.633 21.0497ZM113.345 1.08811L102.721 11.7126C102.01 12.4236 102.01 13.5764 102.721 14.2874L113.345 24.9119C114.056 25.6229 115.209 25.6229 115.92 24.9119L126.545 14.2874C127.256 13.5764 127.256 12.4236 126.545 11.7126L115.92 1.08811C115.209 0.377085 114.056 0.377083 113.345 1.08811ZM80.6667 12.0667C83.7595 12.0667 86.2667 9.55947 86.2667 6.46668C86.2667 3.37388 83.7595 0.866679 80.6667 0.866679C77.5739 0.866679 75.0667 3.37388 75.0667 6.46668C75.0667 9.55947 77.5739 12.0667 80.6667 12.0667ZM88.1333 25.1333C91.2261 25.1333 93.7333 22.6261 93.7333 19.5333C93.7333 16.4406 91.2261 13.9333 88.1333 13.9333C85.0405 13.9333 82.5333 16.4406 82.5333 19.5333C82.5333 22.6261 85.0405 25.1333 88.1333 25.1333ZM78.8 19.5333C78.8 22.6261 76.2928 25.1333 73.2 25.1333C70.1072 25.1333 67.6 22.6261 67.6 19.5333C67.6 16.4406 70.1072 13.9333 73.2 13.9333C76.2928 13.9333 78.8 16.4406 78.8 19.5333ZM53.8945 5.65178L46.8334 18.4031L39.7724 5.65178L53.8945 5.65178ZM48.4464 23.2323C47.7319 24.5226 45.9349 24.5226 45.2204 23.2323L34.9493 4.68404C34.2383 3.40013 35.1333 1.80001 36.5623 1.80001L57.1045 1.80001C58.5336 1.80001 59.4285 3.40013 58.7175 4.68405L48.4464 23.2323ZM5.93897 20.3483L13 7.59693L20.0611 20.3483H5.93897ZM11.387 2.76775C12.1015 1.47744 13.8985 1.47744 14.613 2.76775L24.8841 21.316C25.5951 22.5999 24.7002 24.2 23.2711 24.2H2.72892C1.29988 24.2 0.404947 22.5999 1.11592 21.316L11.387 2.76775Z" style="transition:opacity 1s;opacity:0"></path>
            <defs>
                <linearGradient id="color" x1="18.5985" y1="0.554879" x2="109.834" y2="2.1169" gradientUnits="userSpaceOnUse">
                    <stop stop-color="#82A7F8"></stop>
                    <stop offset="0.5" stop-color="#A6FBF6"></stop>
                    <stop offset="1" stop-color="#CDB0FF"></stop>
                </linearGradient>
            </defs>
        </svg>
        <div class="loading-text">Loading...</div>
    </div>

    <!-- Playing Arts Logo - Always Visible -->
    <svg class="rules-logo" width="128" height="26" viewBox="0 0 128 26" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M114.633 21.0497L106.583 13L114.633 4.95038L122.682 13L114.633 21.0497ZM113.345 1.08811L102.721 11.7126C102.01 12.4236 102.01 13.5764 102.721 14.2874L113.345 24.9119C114.056 25.6229 115.209 25.6229 115.92 24.9119L126.545 14.2874C127.256 13.5764 127.256 12.4236 126.545 11.7126L115.92 1.08811C115.209 0.377085 114.056 0.377083 113.345 1.08811ZM80.6667 12.0667C83.7595 12.0667 86.2667 9.55947 86.2667 6.46668C86.2667 3.37388 83.7595 0.866679 80.6667 0.866679C77.5739 0.866679 75.0667 3.37388 75.0667 6.46668C75.0667 9.55947 77.5739 12.0667 80.6667 12.0667ZM88.1333 25.1333C91.2261 25.1333 93.7333 22.6261 93.7333 19.5333C93.7333 16.4406 91.2261 13.9333 88.1333 13.9333C85.0405 13.9333 82.5333 16.4406 82.5333 19.5333C82.5333 22.6261 85.0405 25.1333 88.1333 25.1333ZM78.8 19.5333C78.8 22.6261 76.2928 25.1333 73.2 25.1333C70.1072 25.1333 67.6 22.6261 67.6 19.5333C67.6 16.4406 70.1072 13.9333 73.2 13.9333C76.2928 13.9333 78.8 16.4406 78.8 19.5333ZM53.8945 5.65178L46.8334 18.4031L39.7724 5.65178L53.8945 5.65178ZM48.4464 23.2323C47.7319 24.5226 45.9349 24.5226 45.2204 23.2323L34.9493 4.68404C34.2383 3.40013 35.1333 1.80001 36.5623 1.80001L57.1045 1.80001C58.5336 1.80001 59.4285 3.40013 58.7175 4.68405L48.4464 23.2323ZM5.93897 20.3483L13 7.59693L20.0611 20.3483H5.93897ZM11.387 2.76775C12.1015 1.47744 13.8985 1.47744 14.613 2.76775L24.8841 21.316C25.5951 22.5999 24.7002 24.2 23.2711 24.2H2.72892C1.29988 24.2 0.404947 22.5999 1.11592 21.316L11.387 2.76775Z"></path>
        <path fill-rule="evenodd" clip-rule="evenodd" fill="url(#color2)" d="M114.633 21.0497L106.583 13L114.633 4.95038L122.682 13L114.633 21.0497ZM113.345 1.08811L102.721 11.7126C102.01 12.4236 102.01 13.5764 102.721 14.2874L113.345 24.9119C114.056 25.6229 115.209 25.6229 115.92 24.9119L126.545 14.2874C127.256 13.5764 127.256 12.4236 126.545 11.7126L115.92 1.08811C115.209 0.377085 114.056 0.377083 113.345 1.08811ZM80.6667 12.0667C83.7595 12.0667 86.2667 9.55947 86.2667 6.46668C86.2667 3.37388 83.7595 0.866679 80.6667 0.866679C77.5739 0.866679 75.0667 3.37388 75.0667 6.46668C75.0667 9.55947 77.5739 12.0667 80.6667 12.0667ZM88.1333 25.1333C91.2261 25.1333 93.7333 22.6261 93.7333 19.5333C93.7333 16.4406 91.2261 13.9333 88.1333 13.9333C85.0405 13.9333 82.5333 16.4406 82.5333 19.5333C82.5333 22.6261 85.0405 25.1333 88.1333 25.1333ZM78.8 19.5333C78.8 22.6261 76.2928 25.1333 73.2 25.1333C70.1072 25.1333 67.6 22.6261 67.6 19.5333C67.6 16.4406 70.1072 13.9333 73.2 13.9333C76.2928 13.9333 78.8 16.4406 78.8 19.5333ZM53.8945 5.65178L46.8334 18.4031L39.7724 5.65178L53.8945 5.65178ZM48.4464 23.2323C47.7319 24.5226 45.9349 24.5226 45.2204 23.2323L34.9493 4.68404C34.2383 3.40013 35.1333 1.80001 36.5623 1.80001L57.1045 1.80001C58.5336 1.80001 59.4285 3.40013 58.7175 4.68405L48.4464 23.2323ZM5.93897 20.3483L13 7.59693L20.0611 20.3483H5.93897ZM11.387 2.76775C12.1015 1.47744 13.8985 1.47744 14.613 2.76775L24.8841 21.316C25.5951 22.5999 24.7002 24.2 23.2711 24.2H2.72892C1.29988 24.2 0.404947 22.5999 1.11592 21.316L11.387 2.76775Z" style="opacity:0"></path>
        <defs>
            <linearGradient id="color2" x1="18.5985" y1="0.554879" x2="109.834" y2="2.1169" gradientUnits="userSpaceOnUse">
                <stop stop-color="#82A7F8"></stop>
                <stop offset="0.5" stop-color="#A6FBF6"></stop>
                <stop offset="1" stop-color="#CDB0FF"></stop>
            </linearGradient>
        </defs>
    </svg>

    <!-- Rules Box -->
    <div class="rules-box" id="rulesBox">
        <div class="rules-content">
            <h3>Crazy Aces - How to Play:</h3>
            <ul>
                <li>Match table card's suit or rank</li>
                <li>Play Ace and pick next suit</li>
                <li>Play Joker then any card on top</li>
                <li>Can't play? Draw a card</li>
                <li>Empty your hand first to win</li>
            </ul>
        </div>

        <button class="rules-ok-btn" onclick="hideRulesBox()">OK</button>
    </div>

    <div class="confetti-container" id="confettiContainer"></div>
    <div class="game-container">
        <div class="opponent-hand-section">
            <div class="opponent-hand-preview" id="opponentHandPreview">
                <!-- Card backs will be generated here -->
            </div>
        </div>

        <div class="status-message" id="statusMessage">
            Loading game...
        </div>

        <div class="play-area">
            <div class="deck-pile" onclick="handleDrawCard()">
                <div class="card card-back" id="deckCard"></div>
                <div class="card-artist" id="deckHint" style="margin-top: 8px;">Draw a card</div>
            </div>

            <div class="discard-pile" id="discardPile">
                <div class="card" id="topCard">
                    <!-- Top discard card -->
                </div>
                <div class="card-stack" id="cardStack">
                    <!-- Previous cards stack here -->
                </div>
            </div>
        </div>

        <div class="player-hand-section">
            <div class="player-hand">
                <div class="hand-cards" id="playerHand">
                    <!-- Player cards will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <div class="suit-selector" id="suitSelector">
        <div class="suit-selector-header">
            <div class="suit-selector-title">Choose a suit</div>
            <button class="close-selector-btn" onclick="closeSuitSelector()">✕</button>
        </div>
        <div class="suit-options">
            <div class="suit-option" id="suit-spades" onclick="chooseSuit('♠️')">♠️</div>
            <div class="suit-option" id="suit-hearts" onclick="chooseSuit('♥️')">♥️</div>
            <div class="suit-option" id="suit-diamonds" onclick="chooseSuit('♦️')">♦️</div>
            <div class="suit-option" id="suit-clubs" onclick="chooseSuit('♣️')">♣️</div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="result-text" id="resultText"></div>
        <button class="play-again-btn" onclick="handlePlayAgain()">Play Again</button>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION CONSTANTS
        // ============================================================================
        const CONFIG = {
            GAME: {
                INITIAL_HAND_SIZE: 7,
                NUM_JOKERS: 2
            },
            ANIMATION: {
                CARD_DROP_DURATION: 400,        // Duration of card drop animation
                CARD_FLY_DURATION: 250,         // Duration of card flying out
                CARD_SHRINK_DURATION: 250,      // Duration of card shrinking
                HINT_SHAKE_DURATION: 600,       // Duration of hint shake animation
                HAND_RESIZE_DURATION: 500       // Duration of hand resize transition
            },
            TIMING: {
                COMPUTER_TURN_DELAY: 800,       // Delay before computer plays
                HINT_INITIAL_DELAY: 5000,       // Initial delay before first hint
                HINT_REPEAT_DELAY: 5000,        // Delay between hint repetitions
                STATUS_MESSAGE_SHORT: 1500,     // Short status message duration
                STATUS_MESSAGE_LONG: 2000,      // Long status message duration
                DRAW_MESSAGE_DELAY: 1200,       // Delay for draw message
                ANIMATION_DELAY: 400,           // General animation delay
                GAME_END_DELAY: 500             // Delay before showing game over
            },
            URLS: {
                BASE_IMAGE: 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/',
                CARD_INFO_BASE: 'https://playingarts.com/one/',
                BACKSIDE_IMAGE: 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/_backside-evgeny-kiselev.jpg?2'
            }
        };

        // ============================================================================
        // CARD DATA
        // ============================================================================
        const cardData = {
            '2♠️': { artist: 'Mattias Adolfsson' }, '3♠️': { artist: 'Teagan White' },
            '4♠️': { artist: 'Serial Cut™' }, '5♠️': { artist: 'Musketon' },
            '6♠️': { artist: 'Fernando Volken Togni' }, '7♠️': { artist: 'Muxxi' },
            '8♠️': { artist: 'Gary Fernández' }, '9♠️': { artist: 'Anton Repponen' },
            '10♠️': { artist: 'Bicicleta Sem Freio' }, 'J♠️': { artist: 'Seb Niark1' },
            'Q♠️': { artist: 'David Mack' }, 'K♠️': { artist: 'Yulia Brodskaya' },
            'A♠️': { artist: 'Iain Macarthur' },

            '2♥️': { artist: 'Peter Tarka' }, '3♥️': { artist: 'Mercedes deBellard' },
            '4♥️': { artist: 'Ruben Ireland' }, '5♥️': { artist: 'Aitch' },
            '6♥️': { artist: 'Javier Medellin Puyou' }, '7♥️': { artist: 'Felix LaFlamme' },
            '8♥️': { artist: 'Raul Urias' }, '9♥️': { artist: 'Carlos Lerma' },
            '10♥️': { artist: 'Caramelaw' }, 'J♥️': { artist: 'Steve Simpson' },
            'Q♥️': { artist: 'Conrad Roset' }, 'K♥️': { artist: 'Sara Blake' },
            'A♥️': { artist: 'Mr. Kone' },

            '2♦️': { artist: 'Yema Yema' }, '3♦️': { artist: 'Carne Griffiths' },
            '4♦️': { artist: 'Peter Olschinsky' }, '5♦️': { artist: 'Fab Ciraolo' },
            '6♦️': { artist: 'VASAVA' }, '7♦️': { artist: 'Matt W. Moore' },
            '8♦️': { artist: 'Jthree Concepts' }, '9♦️': { artist: 'Pirecco' },
            '10♦️': { artist: 'Lei Melendres' }, 'J♦️': { artist: 'Newfren' },
            'Q♦️': { artist: 'agnes-cecile' }, 'K♦️': { artist: 'Saturno (THE CREATTER)' },
            'A♦️': { artist: 'Jordan Debney' },

            '2♣️': { artist: 'Tang Yau Hoong' }, '3♣️': { artist: 'Fernando Chamarelli' },
            '4♣️': { artist: 'MUTI' }, '5♣️': { artist: 'Valerie Ann Chua' },
            '6♣️': { artist: 'Tobias van Schneider' }, '7♣️': { artist: 'Krzysztof CHKN Nowak' },
            '8♣️': { artist: 'El Grand Chamaco' }, '9♣️': { artist: 'Chuck Anderson' },
            '10♣️': { artist: 'Hey' }, 'J♣️': { artist: 'Bakea' },
            'Q♣️': { artist: 'Ise Ananphada' }, 'K♣️': { artist: 'James White' },
            'A♣️': { artist: 'Andreas Preis' },

            'JOKER_1': { artist: 'Mike Friedrich' },
            'JOKER_2': { artist: 'Joshua Davis' }
        };

        const suits = ['♠️', '♥️', '♦️', '♣️'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        let deck = [];
        let playerHand = [];
        let computerHand = [];
        let discardPile = [];
        let currentSuit = null;
        let currentRank = null;
        let gameOver = false;
        let pendingEightCard = null;
        let isComputerTurn = false;
        let isFirstMove = true;
        let suitWasChanged = false;
        let isDrawing = false; // Prevent multiple simultaneous draws
        let jokerWasPlayed = false; // Track if joker was just played
        let hintTimeout = null;
        let isFirstGame = true; // Track if this is the first game after page load
        let playerHasActed = false; // Track if player has made any action yet

        // ============================================================================
        // TIMEOUT MANAGEMENT - Prevent memory leaks
        // ============================================================================
        let activeTimeouts = new Set();

        /**
         * Create a tracked timeout that will be automatically cleaned up
         * @param {Function} callback - Function to execute
         * @param {number} delay - Delay in milliseconds
         * @returns {number} Timeout ID
         */
        function createTimeout(callback, delay) {
            const timeoutId = setTimeout(() => {
                activeTimeouts.delete(timeoutId);
                callback();
            }, delay);
            activeTimeouts.add(timeoutId);
            return timeoutId;
        }

        /**
         * Clear a specific timeout
         * @param {number} timeoutId - The timeout ID to clear
         */
        function clearTrackedTimeout(timeoutId) {
            if (timeoutId) {
                clearTimeout(timeoutId);
                activeTimeouts.delete(timeoutId);
            }
        }

        /**
         * Clear all active timeouts
         */
        function clearAllTimeouts() {
            activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            activeTimeouts.clear();
            if (hintTimeout) {
                clearTimeout(hintTimeout);
                hintTimeout = null;
            }
        }

        // ============================================================================
        // GAME LOGIC
        // ============================================================================

        /**
         * Create a new deck of 54 cards (52 standard + 2 jokers)
         * @returns {Array} Shuffled deck of card objects
         */
        function createDeck() {
            const newDeck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    newDeck.push(createCard(rank, suit));
                }
            }
            // Add 2 jokers
            newDeck.push({ rank: 'JOKER', suit: 'joker', artist: 'Mike Friedrich', isJoker: true });
            newDeck.push({ rank: 'JOKER', suit: 'joker', artist: 'Joshua Davis', isJoker: true });
            return shuffleDeck(newDeck);
        }

        /**
         * Create a card object with artist information
         * @param {string} rank - Card rank (2-10, J, Q, K, A)
         * @param {string} suit - Card suit emoji
         * @returns {Object} Card object
         */
        function createCard(rank, suit) {
            const cardKey = `${rank}${suit}`;
            const data = cardData[cardKey];
            return {
                rank,
                suit,
                artist: data ? data.artist : 'Unknown',
                isAce: rank === 'A',
                isJoker: false
            };
        }

        /**
         * Shuffle deck using Fisher-Yates algorithm
         * @param {Array} deck - Array of card objects
         * @returns {Array} Shuffled deck
         */
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Card image URLs from Playing Arts deck
        const cardImages = {
            '2♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-clubs-tang-yau-hoong.jpg?2',
            '2♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-diamonds-yemayema.jpg?2',
            '2♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-hearts-peter-tarka.jpg?2',
            '2♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-spades-mattias-adolfsson.jpg?2',
            '3♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-clubs-fernando-chamarelli.jpg?2',
            '3♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-diamonds-carne-griffiths.jpg?2',
            '3♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-hearts-mercedes-debellard.jpg?2',
            '3♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-spades-teagan-white.jpg?2',
            '4♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-clubs-muti.jpg?2',
            '4♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-diamonds-peter-olschinsky.jpg?2',
            '4♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-hearts-ruben-ireland.jpg?2',
            '4♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-spades-serial-cut.jpg?2',
            '5♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-clubs-valerie-ann-chua.jpg?2',
            '5♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-diamonds-fab-ciraolo.jpg?2',
            '5♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-hearts-aitch.jpg?2',
            '5♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-spades-musketon.jpg?2',
            '6♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-clubs-tobias-van-schneider.jpg?2',
            '6♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-diamonds-vasava.jpg?2',
            '6♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-hearts-javier-medellin-puyou.jpg?2',
            '6♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-spades-fernando-volken-togni.jpg?2',
            '7♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-clubs-krzysztof-nowak.jpg?2',
            '7♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-diamonds-matt-w-moore.jpg?2',
            '7♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-hearts-felix-laflamme.jpg?2',
            '7♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-spades-muxxi.jpg?2',
            '8♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-clubs-el-grand-chamaco.jpg?2',
            '8♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-diamonds-jthree-concepts.jpg?2',
            '8♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-hearts-raul-urias.jpg?2',
            '8♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-spades-gary-fernandez.jpg?2',
            '9♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-clubs-chuck-anderson.jpg?2',
            '9♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-diamonds-pirecco.jpg?2',
            '9♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-hearts-carlos-lerma.jpg?2',
            '9♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-spades-anton-repponen.jpg?2',
            '10♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-clubs-hey.jpg?2',
            '10♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-diamonds-lei-melendres.jpg?2',
            '10♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-hearts-caramelaw.jpg?2',
            '10♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-spades-bicicleta-sem-freio.jpg?2',
            'J♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-clubs-bakea.jpg?2',
            'J♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-diamonds-newfren.jpg?2',
            'J♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-hearts-steve-simpson.jpg?2',
            'J♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-spades-seb-niark1.jpg?2',
            'Q♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-clubs-ise-ananphada.jpg?2',
            'Q♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-diamonds-agnes-cecile.jpg?2',
            'Q♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-hearts-conrad-roset.jpg?2',
            'Q♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-spades-david-mack.jpg?2',
            'K♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-clubs-james-white.jpg?2',
            'K♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-diamonds-saturno-the-creatter.jpg?2',
            'K♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-hearts-sara-blake.jpg?2',
            'K♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-spades-yulia-brodskaya.jpg?2',
            'A♣️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-clubs-andreas-preis.jpg?2',
            'A♦️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-diamonds-jordan-debney.jpg?2',
            'A♥️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-hearts-mr-kone.jpg?2',
            'A♠️': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-spades-iain-macarthur.jpg?2',
            'JOKER': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/joker-mike-friedrich.jpg?2',
            'JOKER_2': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/joker-joshua-davis.jpg?2'
        };

        /**
         * Get the image URL for a card
         * @param {Object} card - The card object
         * @returns {string} Image URL
         */
        function getCardImageUrl(card) {
            if (card.isJoker) {
                return card.artist === 'Mike Friedrich' ? cardImages['JOKER'] : cardImages['JOKER_2'];
            }
            const key = card.rank + card.suit;
            return cardImages[key] || '';
        }

        /**
         * Get the artist page URL for a card
         * @param {Object} card - The card object
         * @returns {string} Artist page URL
         */
        function getCardUrl(card) {
            // Map artist names to URL slugs
            const artistSlugs = {
                'Mattias Adolfsson': 'mattias-adolfsson',
                'Teagan White': 'teagan-white',
                'Serial Cut™': 'serial-cut',
                'Musketon': 'musketon',
                'Fernando Volken Togni': 'fernando-volken-togni',
                'Muxxi': 'muxxi',
                'Gary Fernández': 'gary-fernández',
                'Anton Repponen': 'anton-repponen',
                'Bicicleta Sem Freio': 'bicicleta-sem-freio',
                'Seb Niark1': 'seb-niark1',
                'David Mack': 'david-mack',
                'Yulia Brodskaya': 'yulia-brodskaya',
                'Iain Macarthur': 'iain-macarthur',
                'Peter Tarka': 'peter-tarka',
                'Mercedes deBellard': 'mercedes-debellard',
                'Ruben Ireland': 'ruben-ireland',
                'Aitch': 'aitch',
                'Javier Medellin Puyou': 'jilipollo',
                'Felix LaFlamme': 'felix-laflamme',
                'Raul Urias': 'raul-urias',
                'Carlos Lerma': 'carlos-lerma',
                'Caramelaw': 'caramelaw',
                'Steve Simpson': 'steve-simpson',
                'Conrad Roset': 'conrad-roset',
                'Sara Blake': 'sara-blake',
                'Mr. Kone': 'mr-kone',
                'Yema Yema': 'yema-yema',
                'Carne Griffiths': 'carne-griffiths',
                'Peter Olschinsky': 'peter-olschinsky',
                'Fab Ciraolo': 'fab-ciraolo',
                'VASAVA': 'vasava',
                'Matt W. Moore': 'matt-w.-moore',
                'Jthree Concepts': 'jthree-concepts',
                'Pirecco': 'pirecco',
                'Lei Melendres': 'lei-melendres',
                'Newfren': 'newfren',
                'agnes-cecile': 'agnes-cecile',
                'Saturno (THE CREATTER)': 'saturno',
                'Jordan Debney': 'jordan-debney',
                'Tang Yau Hoong': 'tang-yau-hoong',
                'Fernando Chamarelli': 'fernando-chamarelli',
                'MUTI': 'muti',
                'Valerie Ann Chua': 'valerie-ann-chua',
                'Tobias van Schneider': 'tobias-van-schneider',
                'Krzysztof CHKN Nowak': 'krzysztof-chkn-nowak',
                'El Grand Chamaco': 'el-grand-chamaco',
                'Chuck Anderson': 'chuck-anderson',
                'Hey': 'hey',
                'Bakea': 'bakea',
                'Ise Ananphada': 'ise-ananphada',
                'James White': 'james-white',
                'Andreas Preis': 'andreas-preis',
                'Mike Friedrich': 'mike-friedrich',
                'Joshua Davis': 'joshua-davis'
            };

            const slug = artistSlugs[card.artist];
            if (slug) {
                return `https://playingarts.com/one/${slug}`;
            }

            return 'https://playingarts.com/one';
        }

        /**
         * Get CSS class name for a suit
         * @param {string} suit - Card suit emoji
         * @returns {string} CSS class name
         */
        function getSuitClass(suit) {
            const suitMap = { '♠️': 'spades', '♥️': 'hearts', '♦️': 'diamonds', '♣️': 'clubs', 'joker': 'joker' };
            return suitMap[suit] || '';
        }

        /**
         * Initialize a new game
         * @async
         * @returns {Promise<void>}
         */
        async function initGame() {
            try {
                // Clear all existing timeouts to prevent memory leaks
                clearAllTimeouts();

                deck = createDeck();
                console.log(`Deck created with ${deck.length} cards`);
                playerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);
                computerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);
                console.log(`After dealing: ${deck.length} cards remaining in deck`);

                // First discard card (not Ace or joker)
                let firstCard;
                do {
                    firstCard = deck.shift();
                } while (firstCard.isAce || firstCard.isJoker);

                discardPile = [firstCard];
                currentSuit = firstCard.suit;
                currentRank = firstCard.rank;

                // Ensure player has at least one playable card
                const hasPlayableCard = playerHand.some(card =>
                    card.isJoker || card.isAce || card.suit === currentSuit || card.rank === currentRank
                );

                if (!hasPlayableCard) {
                    // Find a matching card in the deck and swap with a random card in player's hand
                    const matchingCardIndex = deck.findIndex(card =>
                        card.suit === currentSuit || card.rank === currentRank
                    );
                    if (matchingCardIndex !== -1) {
                        const matchingCard = deck.splice(matchingCardIndex, 1)[0];
                        const randomIndex = Math.floor(Math.random() * playerHand.length);
                        deck.push(playerHand[randomIndex]);
                        playerHand[randomIndex] = matchingCard;
                    }
                }

                gameOver = false;
                pendingEightCard = null;
                isComputerTurn = false;
                isFirstMove = true;
                suitWasChanged = false;
                isDrawing = false;
                jokerWasPlayed = false;
                playerHasActed = false;

                // Clear any existing hint timeout
                if (hintTimeout) {
                    clearTimeout(hintTimeout);
                    hintTimeout = null;
                }

                // Preload hand images and table card
                updateStatus('Loading cards...');
                const tableCardUrl = getCardImageUrl(firstCard);
                if (tableCardUrl) {
                    await preloadImage(tableCardUrl);
                }
                await preloadHandImages();

                // Show both player and computer hands - reset opacity
                const opponentHand = document.getElementById('opponentHandPreview');
                const playerHandContainer = document.querySelector('.player-hand');
                const playerHandSection = document.querySelector('.player-hand-section');
                if (opponentHand) {
                    opponentHand.style.display = 'flex';
                    opponentHand.style.visibility = 'visible';
                    opponentHand.style.opacity = '1';
                }
                if (playerHandContainer) {
                    playerHandContainer.style.display = 'block';
                    playerHandContainer.style.visibility = 'visible';
                    playerHandContainer.style.opacity = '1';
                }
                if (playerHandSection) {
                    playerHandSection.style.opacity = '1';
                }

                document.getElementById('gameOver').classList.remove('show');
                updateStatus('Play a card matching the table card\'s suit or rank');
                updateDisplay();
                console.log(`Game started. Deck: ${deck.length}, Player: ${playerHand.length}, Computer: ${computerHand.length}, Discard: ${discardPile.length}`);

                // Start hint timer only on first game after page load
                if (isFirstGame) {
                    hintTimeout = setTimeout(showPlayableCardHint, CONFIG.TIMING.HINT_INITIAL_DELAY);
                }
            } catch (error) {
                console.error('Error initializing game:', error);
                updateStatus('Error starting game. Please refresh the page.');
            }
        }

        /**
         * Wrapper functions for onclick handlers to handle async operations
         * @async
         * @returns {Promise<void>}
         */
        async function handlePlayAgain() {
            try {
                await initGame();
            } catch (error) {
                console.error('Error restarting game:', error);
                updateStatus('Error restarting game. Please refresh the page.');
            }
        }

        /**
         * Wrapper function for draw card action
         * @async
         * @returns {Promise<void>}
         */
        async function handleDrawCard() {
            try {
                await drawCard();
            } catch (error) {
                console.error('Error drawing card:', error);
                updateStatus('Error drawing card. Please try again.');
                isDrawing = false;
            }
        }

        function showPlayableCardHint() {
            if (gameOver || isComputerTurn || playerHasActed) {
                return;
            }

            // Find all playable cards
            const handEl = document.getElementById('playerHand');
            const cardElements = handEl.querySelectorAll('.hand-card');

            cardElements.forEach((cardEl, visualIndex) => {
                const cardIndex = parseInt(cardEl.dataset.cardIndex);
                const card = playerHand[cardIndex];

                if (card && canPlayCard(card)) {
                    // Add shake animation
                    cardEl.classList.add('hint-shake');

                    // Remove animation class after it completes
                    setTimeout(() => {
                        cardEl.classList.remove('hint-shake');
                    }, 600);
                }
            });

            // Schedule next hint in 5 seconds
            hintTimeout = setTimeout(showPlayableCardHint, 5000);
        }

        function updateDisplay(animate = true, animateFrom = 'top') {
            renderOpponentHand();
            renderTopCard(animate, animateFrom);
            renderPlayerHand();
        }

        function renderOpponentHand() {
            const container = document.getElementById('opponentHandPreview');
            container.innerHTML = '';

            for (let i = 0; i < computerHand.length; i++) {
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back-small';
                container.appendChild(cardBack);
            }
        }

        /**
         * Render the top card on the discard pile
         * @param {boolean} animate - Whether to animate the card
         * @param {string} animateFrom - Direction to animate from ('top' or 'bottom')
         */
        function renderTopCard(animate = true, animateFrom = 'top') {
            const topCardEl = document.getElementById('topCard');
            const card = discardPile[discardPile.length - 1];
            const imageUrl = getCardImageUrl(card);

            // First card is straight (0°), subsequent cards have slight rotation (-3 to 3 degrees)
            const isFirstCard = discardPile.length === 1;
            const rotation = isFirstCard ? 0 : (Math.random() - 0.5) * 6;

            // Only add animation class if animate is true, with direction
            const animationClass = animate ? `card card-animating-from-${animateFrom}` : 'card';
            topCardEl.className = animationClass;
            topCardEl.style.backgroundImage = `url('${imageUrl}')`;
            topCardEl.style.setProperty('--rotation', `${rotation}deg`);
            topCardEl.style.transform = `rotate(${rotation}deg)`;

            // Remove animation class after animation completes
            if (animate) {
                setTimeout(() => {
                    topCardEl.classList.remove(`card-animating-from-${animateFrom}`);
                }, 400);
            }
            
            // Render previous cards stack (last 3 cards before current)
            const stackEl = document.getElementById('cardStack');
            stackEl.innerHTML = '';
            
            const stackCount = Math.min(3, discardPile.length - 1);
            for (let i = 1; i <= stackCount; i++) {
                const prevCard = discardPile[discardPile.length - 1 - i];
                const prevImageUrl = getCardImageUrl(prevCard);
                const stackCard = document.createElement('div');
                stackCard.className = 'card';
                stackCard.style.backgroundImage = `url('${prevImageUrl}')`;
                stackCard.style.position = 'absolute';
                stackCard.style.zIndex = -i;
                
                // Slight offset and rotation for stacked cards (-3 to 3 degrees)
                const stackRotation = (Math.random() - 0.5) * 6;
                stackCard.style.transform = `translate(${i * -3}px, ${i * 2}px) rotate(${stackRotation}deg)`;
                stackCard.style.opacity = 0.3;
                
                stackEl.appendChild(stackCard);
            }
            
            // If suit was changed (Ace/Joker played and suit selected), show the NEW suit
            if (suitWasChanged && (card.isJoker || card.isAce)) {
                topCardEl.innerHTML = `
                    <div class="card-info">
                        <span class="info-suit">${currentSuit}</span>
                    </div>
                `;
            } else if (card.isJoker) {
                // Show JOKER text below image (before suit is chosen)
                topCardEl.innerHTML = `
                    <div class="card-info">
                        <span class="info-joker">JOKER</span>
                    </div>
                    <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
                `;
                
                // Add animation class
                topCardEl.classList.add('wild-card-played');
                setTimeout(() => {
                    topCardEl.classList.remove('wild-card-played');
                }, 1000);
            } else if (card.isAce) {
                // Show Ace rank and suit below image (before suit is chosen)
                topCardEl.innerHTML = `
                    <div class="card-info">
                        <span class="info-rank">${card.rank}</span>
                        <span class="info-suit">${card.suit}</span>
                    </div>
                    <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
                `;
                
                // Add animation class
                topCardEl.classList.add('wild-card-played');
                setTimeout(() => {
                    topCardEl.classList.remove('wild-card-played');
                }, 1000);
            } else {
                // Show rank and suit below image for regular cards
                topCardEl.innerHTML = `
                    <div class="card-info">
                        <span class="info-rank">${card.rank}</span>
                        <span class="info-suit">${card.suit}</span>
                    </div>
                    <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
                `;
            }
        }

        /**
         * Drag and drop handlers
         */
        let draggedCardIndex = null;
        let touchStartY = 0;
        let touchStartX = 0;
        let isDragging = false;

        function handleDragStart(e, index) {
            draggedCardIndex = index;
            e.target.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            draggedCardIndex = null;
        }

        function handleTouchStart(e, index) {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            draggedCardIndex = index;
            isDragging = false;
        }

        function handleTouchMove(e) {
            if (draggedCardIndex === null) return;

            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);

            // Start dragging if moved more than 10px
            if (deltaX > 10 || deltaY > 10) {
                isDragging = true;
                e.preventDefault(); // Prevent scrolling while dragging

                // Check if over discard pile
                const discardPileEl = document.getElementById('discardPile');
                if (discardPileEl) {
                    const rect = discardPileEl.getBoundingClientRect();
                    const isOver = touch.clientX >= rect.left && touch.clientX <= rect.right &&
                                   touch.clientY >= rect.top && touch.clientY <= rect.bottom;

                    if (isOver && !discardPileEl.classList.contains('drag-over')) {
                        discardPileEl.classList.add('drag-over');
                    } else if (!isOver && discardPileEl.classList.contains('drag-over')) {
                        discardPileEl.classList.remove('drag-over');
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (draggedCardIndex === null) return;

            const discardPileEl = document.getElementById('discardPile');
            if (discardPileEl) {
                discardPileEl.classList.remove('drag-over');
            }

            // Only play card if dragged (not just a tap)
            if (isDragging) {
                const touch = e.changedTouches[0];
                if (discardPileEl) {
                    const rect = discardPileEl.getBoundingClientRect();
                    const isOver = touch.clientX >= rect.left && touch.clientX <= rect.right &&
                                   touch.clientY >= rect.top && touch.clientY <= rect.bottom;

                    if (isOver) {
                        playCard(draggedCardIndex);
                    }
                }
            }

            draggedCardIndex = null;
            isDragging = false;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            // Add visual feedback
            const discardPileEl = document.getElementById('discardPile');
            if (discardPileEl && !discardPileEl.classList.contains('drag-over')) {
                discardPileEl.classList.add('drag-over');
            }

            return false;
        }

        function handleDragLeave(e) {
            const discardPileEl = document.getElementById('discardPile');
            if (discardPileEl) {
                discardPileEl.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            // Remove visual feedback
            const discardPileEl = document.getElementById('discardPile');
            if (discardPileEl) {
                discardPileEl.classList.remove('drag-over');
            }

            if (draggedCardIndex !== null) {
                playCard(draggedCardIndex);
            }

            return false;
        }

        /**
         * Render the player's hand to the DOM
         */
        function renderPlayerHand() {
            const handEl = document.getElementById('playerHand');
            handEl.innerHTML = '';

            // Separate cards: Jokers first, then Aces, then other cards
            const jokers = playerHand.filter(card => card.isJoker);
            const aces = playerHand.filter(card => card.isAce && !card.isJoker);
            const regularCards = playerHand.filter(card => !card.isAce && !card.isJoker);

            // Render Jokers first (most left)
            jokers.forEach((card) => {
                const actualIndex = playerHand.indexOf(card);
                const cardEl = document.createElement('div');
                cardEl.className = 'hand-card joker-card';
                cardEl.dataset.cardIndex = actualIndex;
                cardEl.innerHTML = `
                    <div class="card-rank joker-text">JOKER</div>
                `;

                if (!gameOver) {
                    cardEl.onclick = () => playCard(actualIndex);
                    cardEl.draggable = true;
                    cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
                    cardEl.ondragend = handleDragEnd;
                    cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
                    cardEl.ontouchmove = handleTouchMove;
                    cardEl.ontouchend = handleTouchEnd;
                }

                handEl.appendChild(cardEl);
            });

            // Render Aces second
            aces.forEach((card) => {
                const actualIndex = playerHand.indexOf(card);
                const cardEl = document.createElement('div');
                cardEl.className = 'hand-card ace-card';
                cardEl.dataset.cardIndex = actualIndex;
                // Show only "A" for Aces, no suit symbol
                cardEl.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                `;

                if (!gameOver) {
                    cardEl.onclick = () => playCard(actualIndex);
                    cardEl.draggable = true;
                    cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
                    cardEl.ondragend = handleDragEnd;
                    cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
                    cardEl.ontouchmove = handleTouchMove;
                    cardEl.ontouchend = handleTouchEnd;
                }

                handEl.appendChild(cardEl);
            });

            // Render regular cards last
            regularCards.forEach((card) => {
                const actualIndex = playerHand.indexOf(card);
                const cardEl = document.createElement('div');
                cardEl.className = 'hand-card';
                cardEl.dataset.cardIndex = actualIndex;

                cardEl.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${card.suit}</div>
                `;

                if (!gameOver) {
                    cardEl.onclick = () => playCard(actualIndex);
                    cardEl.draggable = true;
                    cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
                    cardEl.ondragend = handleDragEnd;
                    cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
                    cardEl.ontouchmove = handleTouchMove;
                    cardEl.ontouchend = handleTouchEnd;
                }

                handEl.appendChild(cardEl);
            });
        }

        /**
         * Check if a card can be played on the current card
         * @param {Object} card - The card to check
         * @returns {boolean} True if the card can be played
         */
        function canPlayCard(card) {
            if (!card) return false;
            if (card.isJoker) return true;
            if (card.isAce) return true;
            if (jokerWasPlayed) return true; // Any card can be played after joker
            if (card.suit === currentSuit) return true;
            if (card.rank === currentRank) return true;
            return false;
        }

        /**
         * Play a card from the player's hand
         * @param {number} index - The index of the card in the player's hand
         */
        function playCard(index) {
            if (gameOver || isComputerTurn || pendingEightCard) return;

            const card = playerHand[index];

            // Safety check
            if (!card) return;

            // Check if card can be played
            if (!canPlayCard(card)) {
                updateStatus('Cannot play that card');
                setTimeout(() => updateStatus(''), 1500);
                return;
            }

            // LOCK TURN IMMEDIATELY before any other operations
            isComputerTurn = true;

            // Mark that player has acted
            if (!playerHasActed) {
                playerHasActed = true;
                // Clear hint timeout on first action
                if (hintTimeout) {
                    clearTimeout(hintTimeout);
                    hintTimeout = null;
                }
                // Disable hints for future games
                isFirstGame = false;
            }

            // Clear rules message on first move
            if (isFirstMove) {
                isFirstMove = false;
            }

            // Animate the card flying out FIRST - find the correct card element by its data-card-index
            const handEl = document.getElementById('playerHand');
            const cardElement = handEl.querySelector(`[data-card-index="${index}"]`);
            if (cardElement) {
                cardElement.classList.add('card-flying-out');
            }

            // Immediately remove from array and re-render for smooth hand resize
            playerHand.splice(index, 1);
            discardPile.push(card);
            renderPlayerHand();

            // Card from hand is already preloaded - no need to preload again

            // Reset suit change flag for new card
            suitWasChanged = false;

            if (card.isJoker) {
                // Joker = wild - play any card next to define suit
                jokerWasPlayed = true;
                isComputerTurn = false; // Keep turn unlocked
                updateStatus('You played Joker - play another card to define the suit');
                // Update table card and opponent hand immediately
                renderOpponentHand();
                renderTopCard(true, 'bottom');
                return;
            }

            // Check if this card was played after a Joker
            const wasAfterJoker = jokerWasPlayed;
            if (jokerWasPlayed) {
                jokerWasPlayed = false;
                suitWasChanged = true; // Show that suit was changed by joker
            }

            if (card.isAce) {
                // Ace = change suit
                pendingEightCard = card;
                isComputerTurn = false; // Unlock while waiting for suit selection
                updateStatus('You played Ace - choose a suit');
                updateSuitSelector(); // Update which suits are available
                document.getElementById('suitSelector').classList.add('show');
                return;
            }

            currentSuit = card.suit;
            currentRank = card.rank;

            if (wasAfterJoker) {
                updateStatus(`You played ${card.rank}${card.suit} - suit is now ${card.suit}`);
                setTimeout(() => updateStatus(''), 2000);
            } else {
                updateStatus(`You played ${card.rank}${card.suit}`);
                setTimeout(() => updateStatus(''), 1500);
            }

            // Update table card and opponent hand immediately
            renderOpponentHand();
            renderTopCard(true, 'bottom');

            // Wait for fly-out animation before starting computer turn
            setTimeout(() => {

            if (playerHand.length === 0) {
                // Hide player hand immediately with the card animation
                const playerHandContainer = document.querySelector('.player-hand');
                const playerHandSection = document.querySelector('.player-hand-section');
                if (playerHandContainer) {
                    playerHandContainer.style.transition = 'opacity 0.25s ease';
                    playerHandContainer.style.opacity = '0';
                }
                // Also hide the section on mobile
                if (playerHandSection && window.innerWidth <= 480) {
                    playerHandSection.style.opacity = '0';
                }
                setTimeout(() => {
                    endGame('player');
                }, 500);
                return;
            }

            setTimeout(async () => {
                await computerTurn();
            }, CONFIG.TIMING.COMPUTER_TURN_DELAY);
            }, CONFIG.ANIMATION.CARD_FLY_DURATION); // Wait for fly-out animation
        }

        function chooseSuit(suit) {
            document.getElementById('suitSelector').classList.remove('show');
            currentSuit = suit;
            currentRank = pendingEightCard.rank;
            
            const wasJoker = pendingEightCard.isJoker;
            
            // Transform the Ace/Joker card in discard pile to show the chosen suit
            if (pendingEightCard.isAce) {
                // Find the last card in discard pile (should be the Ace just played)
                const lastCard = discardPile[discardPile.length - 1];
                lastCard.suit = suit; // Change suit to chosen suit
                lastCard.isAce = false; // No longer wild - it's now a specific Ace
                suitWasChanged = false; // Don't need special rendering
            } else {
                suitWasChanged = true; // Keep flag for Jokers
            }
            
            pendingEightCard = null;

            updateStatus(`You changed suit to ${suit}`);
            setTimeout(() => updateStatus(''), 2000);

            updateDisplay(true, 'bottom');

            if (playerHand.length === 0) {
                setTimeout(() => {
                    endGame('player');
                }, 500);
                return;
            }

            // If joker was played, skip computer's turn
            if (!wasJoker) {
                isComputerTurn = true;
                setTimeout(async () => {
                    await computerTurn();
                }, 800);
            }
        }

        function updateSuitSelector() {
            // Check which Aces have been played in the discard pile
            const playedAceSuits = new Set();
            discardPile.forEach(card => {
                if (card.rank === 'A' && !card.isAce) {
                    // This is an Ace that has been transformed (suit was chosen)
                    playedAceSuits.add(card.suit);
                }
            });
            
            // Enable/disable suit options based on played Aces
            const suitMap = {
                '♠️': 'suit-spades',
                '♥️': 'suit-hearts',
                '♦️': 'suit-diamonds',
                '♣️': 'suit-clubs'
            };
            
            Object.entries(suitMap).forEach(([suit, id]) => {
                const element = document.getElementById(id);
                if (playedAceSuits.has(suit)) {
                    element.classList.add('disabled');
                } else {
                    element.classList.remove('disabled');
                }
            });
        }

        function closeSuitSelector() {
            // Return the card to player's hand
            if (pendingEightCard) {
                discardPile.pop(); // Remove from discard pile
                playerHand.push(pendingEightCard); // Add back to hand
                pendingEightCard = null;
            }

            isComputerTurn = false; // Unlock turn for player

            document.getElementById('suitSelector').classList.remove('show');
            updateDisplay();
            updateStatus('Card returned to hand');
            setTimeout(() => updateStatus(''), 1500);
        }

        /**
         * Draw a card from the deck
         * @async
         * @returns {Promise<void>}
         */
        async function drawCard() {
            try {
                // Check all locks including the drawing lock
                if (gameOver || isComputerTurn || pendingEightCard || isDrawing) return;

                // LOCK DRAWING IMMEDIATELY before any other operations
                isDrawing = true;
                isComputerTurn = true;

            // Mark that player has acted
            if (!playerHasActed) {
                playerHasActed = true;
                // Clear hint timeout on first action
                if (hintTimeout) {
                    clearTimeout(hintTimeout);
                    hintTimeout = null;
                }
                // Disable hints for future games
                isFirstGame = false;
            }

            // Hide deck hint after drawing (always, not just first time)
            const deckHint = document.getElementById('deckHint');
            if (deckHint) {
                deckHint.style.display = 'none';
            }

            // Clear rules message on first move
            if (isFirstMove) {
                isFirstMove = false;
            }

            // Clear joker flag if drawing after joker
            if (jokerWasPlayed) {
                jokerWasPlayed = false;
            }

            if (deck.length === 0) {
                updateStatus('Deck empty - pass turn');
                setTimeout(async () => {
                    updateStatus('');
                    isDrawing = false; // Unlock drawing
                    await computerTurn();
                }, 1500);
                return;
            }

            const card = deck.shift();
            if (!card) {
                // Safety check - deck was empty
                updateStatus('Deck empty - pass turn');
                setTimeout(async () => {
                    updateStatus('');
                    isDrawing = false; // Unlock drawing
                    await computerTurn();
                }, 1500);
                return;
            }

            playerHand.push(card);

            // Preload the drawn card before allowing it to be played
            await preloadCardOnDraw(card);

            animateDeckDraw(); // Animate the deck pile
            updateStatus('You drew a card');
            setTimeout(() => updateStatus(''), 1200);
            updateDisplay(false); // No animation when drawing

            if (!canPlayCard(card)) {
                // Card can't be played, computer's turn
                setTimeout(async () => {
                    isDrawing = false; // Unlock drawing before computer turn
                    await computerTurn();
                }, 1000);
                } else {
                    // Card can be played, unlock turn for player to play it
                    isComputerTurn = false;
                    isDrawing = false; // Unlock drawing
                }
            } catch (error) {
                console.error('Error drawing card:', error);
                isDrawing = false;
                isComputerTurn = false;
                updateStatus('Error drawing card. Please try again.');
            }
        }

        /**
         * Computer's turn to play
         * @async
         * @returns {Promise<void>}
         */
        async function computerTurn() {
            try {
                if (gameOver) return;

                // Find playable cards
                const playableCards = computerHand.filter(canPlayCard);

                if (playableCards.length === 0) {
                    // Must draw
                    if (deck.length > 0) {
                        const card = deck.shift();
                        if (!card) {
                            // Deck empty after shift
                            updateDisplay(false); // No animation
                            isComputerTurn = false;
                            return;
                        }
                        computerHand.push(card);

                        // Preload the drawn card before playing it
                        await preloadCardOnDraw(card);

                        animateDeckDraw(); // Animate the deck pile
                        updateStatus('Computer drew a card');
                        setTimeout(() => updateStatus(''), 1200);
                        updateDisplay(false); // Update display without animating the face-up card

                        if (canPlayCard(card)) {
                            setTimeout(() => {
                                const index = computerHand.indexOf(card);
                                if (index !== -1) {
                                    computerPlayCard(index);
                                } else {
                                    isComputerTurn = false;
                                }
                            }, 1200);
                        } else {
                            setTimeout(() => {
                                isComputerTurn = false;
                            }, 1200);
                        }
                    } else {
                        // Deck empty, computer must pass
                        updateStatus('Computer passes');
                        setTimeout(() => updateStatus(''), 1500);
                        isComputerTurn = false;
                    }
                    return;
                }

                // Play lowest non-special card, or special if needed
                playableCards.sort((a, b) => {
                    if (a.isJoker) return 1;
                    if (b.isJoker) return -1;
                    if (a.isAce) return 1;
                    if (b.isAce) return -1;
                    const rankOrder = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
                    return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank);
                });

                const cardToPlay = playableCards[0];
                const index = computerHand.indexOf(cardToPlay);
            
                if (index !== -1) {
                    setTimeout(() => {
                        computerPlayCard(index);
                    }, CONFIG.TIMING.COMPUTER_TURN_DELAY);
                } else {
                    isComputerTurn = false;
                }
            } catch (error) {
                console.error('Error in computer turn:', error);
                isComputerTurn = false;
                updateStatus('Error in computer turn. Please try again.');
            }
        }

        function computerPlayCard(index) {
            const card = computerHand[index];

            // Animate the card flying out from opponent hand
            const opponentHandEl = document.getElementById('opponentHandPreview');
            const cardElements = opponentHandEl.querySelectorAll('.card-back-small');
            if (cardElements[index]) {
                cardElements[index].classList.add('card-flying-out-opponent');
                // Also set width to 0 with transition for smooth resize
                setTimeout(() => {
                    cardElements[index].style.transition = 'all 0.25s ease';
                    cardElements[index].style.width = '0';
                    cardElements[index].style.marginRight = '0';
                    cardElements[index].style.opacity = '0';
                }, 150);
            }

            // Wait for animation before removing card from array
            setTimeout(() => {
                computerHand.splice(index, 1);
                discardPile.push(card);

            // Card from hand is already preloaded - no need to preload again

            if (card.isJoker) {
                // Set flag that joker was played
                jokerWasPlayed = true;
                updateStatus('Computer played Joker');
                setTimeout(() => updateStatus(''), 1500);

                // Update display after Joker
                updateDisplay();

                // Check if game is over
                if (computerHand.length === 0) {
                    setTimeout(() => {
                        endGame('computer');
                    }, 500);
                    return;
                }

                // Continue turn - play another card after delay
                setTimeout(() => {
                    const playableCards = computerHand.filter(canPlayCard);
                    if (playableCards.length > 0) {
                        // Choose best card (prefer cards matching most common suit)
                        const suitCounts = {};
                        computerHand.forEach(c => {
                            if (!c.isJoker && !c.isAce) {
                                suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
                            }
                        });
                        const bestSuit = Object.keys(suitCounts).sort((a,b) => suitCounts[b] - suitCounts[a])[0];

                        // Prefer card with best suit
                        let cardToPlay = playableCards.find(c => c.suit === bestSuit) || playableCards[0];
                        const cardIndex = computerHand.indexOf(cardToPlay);
                        computerPlayCard(cardIndex);
                    } else {
                        // Can't play, end turn
                        jokerWasPlayed = false;
                        isComputerTurn = false;
                    }
                }, 1500);
                return; // Exit early, turn continues
            } else if (card.isAce) {
                // Choose most common suit in hand
                const suitCounts = {};
                computerHand.forEach(c => {
                    if (!c.isJoker && !c.isAce) {
                        suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
                    }
                });
                const bestSuit = Object.keys(suitCounts).sort((a,b) => suitCounts[b] - suitCounts[a])[0] || suits[0];
                currentSuit = bestSuit;
                currentRank = card.rank;

                // Transform the Ace card to show the chosen suit
                card.suit = bestSuit;
                card.isAce = false; // No longer wild
                suitWasChanged = false;

                updateStatus(`Computer played Ace - changed to ${currentSuit}`);
                setTimeout(() => updateStatus(''), 2500);
            } else {
                // If this card was played after a Joker, clear the flag
                if (jokerWasPlayed) {
                    jokerWasPlayed = false;
                    suitWasChanged = true;
                    updateStatus(`Computer played ${card.rank}${card.suit} after Joker`);
                    setTimeout(() => updateStatus(''), 2000);
                } else {
                    suitWasChanged = false;
                    updateStatus(`Computer played ${card.rank}${card.suit}`);
                    setTimeout(() => updateStatus(''), 1500);
                }
                currentSuit = card.suit;
                currentRank = card.rank;
            }

            updateDisplay();

            if (computerHand.length === 0) {
                // Hide computer hand immediately with the card animation
                const opponentHandContainer = document.getElementById('opponentHandPreview');
                if (opponentHandContainer) {
                    opponentHandContainer.style.transition = 'opacity 0.25s ease';
                    opponentHandContainer.style.opacity = '0';
                }
                setTimeout(() => {
                    endGame('computer');
                }, 500);
                return;
            }

                isComputerTurn = false; // Unlock turn for player
            }, CONFIG.ANIMATION_DELAY); // Animation delay - wait for card to fly and resize
        }

        /**
         * Update status message display
         * @param {string} message - The status message to display
         */
        function updateStatus(message) {
            const statusEl = document.getElementById('statusMessage');
            if (message) {
                statusEl.textContent = message;
            } else {
                statusEl.textContent = '';
            }
        }

        /**
         * Animate the deck pile when a card is drawn
         */
        function animateDeckDraw() {
            const deckPile = document.querySelector('.deck-pile');
            deckPile.classList.add('deck-drawing');
            setTimeout(() => {
                deckPile.classList.remove('deck-drawing');
            }, CONFIG.ANIMATION.CARD_DROP_DURATION);
        }

        /**
         * End the game and display the result
         * @param {string} winner - 'player' or 'computer'
         */
        function endGame(winner) {
            gameOver = true;

            const gameOverEl = document.getElementById('gameOver');
            const resultText = document.getElementById('resultText');

            if (winner === 'player') {
                resultText.textContent = 'You Win!';
                resultText.className = 'result-text win';
                launchConfetti();
            } else {
                resultText.textContent = 'Computer Wins';
                resultText.className = 'result-text lose';
            }

            gameOverEl.classList.add('show');
        }

        function launchConfetti() {
            const container = document.getElementById('confettiContainer');
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff1493'];
            const confettiCount = 150;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = '0s';
                    
                    container.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 5000);
                }, i * 30);
            }
        }

        function hideRulesBox() {
            const rulesBox = document.getElementById('rulesBox');
            if (rulesBox) {
                rulesBox.classList.add('hidden');
            }
        }

        // Progressive image preloading system
        window.preloadedImages = window.preloadedImages || [];
        window.preloadedUrls = window.preloadedUrls || new Set();

        // Preload a single image
        function preloadImage(url) {
            if (!url || window.preloadedUrls.has(url)) {
                return Promise.resolve(); // Already loaded or invalid
            }

            return new Promise((resolve, reject) => {
                const img = new Image();
                // Remove crossOrigin to avoid CORS issues with caching
                img.loading = "eager";
                img.decoding = "async";

                img.onload = () => {
                    window.preloadedUrls.add(url);
                    window.preloadedImages.push(img); // Keep reference to prevent garbage collection
                    console.log('✓ Loaded:', url.split('/').pop());
                    resolve();
                };
                img.onerror = (e) => {
                    console.error(`Failed to load: ${url}`, e);
                    window.preloadedUrls.add(url); // Mark as attempted to avoid retry loops
                    resolve(); // Resolve anyway to not block
                };
                img.src = url;

                // If already cached/loaded immediately, resolve
                if (img.complete && img.naturalWidth > 0) {
                    window.preloadedUrls.add(url);
                    window.preloadedImages.push(img);
                    resolve();
                }
            });
        }

        /**
         * Preload both player and computer hand cards in background
         * @async
         * @returns {Promise<void>}
         */
        async function preloadHandImages() {
            try {
                const urls = [];
                let hasAce = false;

                // Player hand
                playerHand.forEach(card => {
                    const url = getCardImageUrl(card);
                    if (url) urls.push(url);
                    if (card.isAce) hasAce = true;
                });

                // Computer hand
                computerHand.forEach(card => {
                    const url = getCardImageUrl(card);
                    if (url) urls.push(url);
                    if (card.isAce) hasAce = true;
                });

                await Promise.all(urls.map(url => preloadImage(url)));
                console.log(`✓ Hand images loaded (${urls.length} cards)`);

                // If any hand has an ace, preload all 4 aces
                if (hasAce) {
                    await preloadAllAces();
                }
            } catch (error) {
                console.error('Error preloading hand images:', error);
                // Continue anyway - images will load on demand
            }
        }

        /**
         * Preload all four aces (since aces can change suit)
         * @async
         * @returns {Promise<void>}
         */
        async function preloadAllAces() {
            try {
                const aceUrls = [
                    cardImages['A♠️'],
                    cardImages['A♥️'],
                    cardImages['A♦️'],
                    cardImages['A♣️']
                ];
                await Promise.all(aceUrls.map(url => preloadImage(url)));
                console.log('✓ All 4 aces preloaded');
            } catch (error) {
                console.error('Error preloading aces:', error);
                // Continue anyway - images will load on demand
            }
        }

        /**
         * Preload card when drawn from deck
         * @async
         * @param {Object} card - The card to preload
         * @returns {Promise<void>}
         */
        async function preloadCardOnDraw(card) {
            try {
                const url = getCardImageUrl(card);
                if (url) {
                    await preloadImage(url);
                }

                // If it's an ace, preload all aces (since ace can change suit)
                if (card.isAce) {
                    await preloadAllAces();
                }
            } catch (error) {
                console.error('Error preloading card on draw:', error);
                // Continue anyway - image will load on demand
            }
        }

        // Initialize - progressive loading
        async function initialize() {
            try {
                // Initialize game data without displaying
                deck = createDeck();
                playerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);
                computerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);

                // First discard card (not Ace or joker)
                let firstCard;
                do {
                    firstCard = deck.shift();
                } while (firstCard.isAce || firstCard.isJoker);

                discardPile = [firstCard];
                currentSuit = firstCard.suit;
                currentRank = firstCard.rank;

                // Load only critical images (backside + table card)
                const tableCardUrl = getCardImageUrl(firstCard);
                const backsideUrl = CONFIG.URLS.BACKSIDE_IMAGE;

                const criticalPromises = [
                    preloadImage(backsideUrl),
                    tableCardUrl ? preloadImage(tableCardUrl) : Promise.resolve()
                ];

                await Promise.all(criticalPromises);
                console.log('✓ Critical images loaded (backside + table card)');

                updateStatus('Loading cards...');

                // Preload ALL hand cards before displaying game
                await preloadHandImages();
                console.log('✓ All hand images preloaded');
                console.log('Preloaded images count:', window.preloadedImages.length);
                console.log('Preloaded URLs count:', window.preloadedUrls.size);

                // Now display the game with everything ready
                gameOver = false;
                pendingEightCard = null;
                isComputerTurn = false;
                isFirstMove = true;
                suitWasChanged = false;
                isDrawing = false;
                jokerWasPlayed = false;
                playerHasActed = false;

                // Show both player and computer hands
                const opponentHand = document.getElementById('opponentHandPreview');
                const playerHandContainer = document.querySelector('.player-hand');
                if (opponentHand) {
                    opponentHand.style.display = 'flex';
                    opponentHand.style.visibility = 'visible';
                }
                if (playerHandContainer) {
                    playerHandContainer.style.display = 'block';
                    playerHandContainer.style.visibility = 'visible';
                }

                document.getElementById('gameOver').classList.remove('show');
                updateStatus('Play a card matching the table card\'s suit or rank');
                updateDisplay();

                // Initialize drag and drop zone
                const discardPileEl = document.getElementById('discardPile');
                if (discardPileEl) {
                    discardPileEl.ondragover = handleDragOver;
                    discardPileEl.ondragleave = handleDragLeave;
                    discardPileEl.ondrop = handleDrop;
                }

                // Start hint timer only on first game after page load
                if (isFirstGame) {
                    hintTimeout = setTimeout(showPlayableCardHint, CONFIG.TIMING.HINT_INITIAL_DELAY);
                }

                // Fade in the game and hide loading screen after everything is loaded
                setTimeout(() => {
                    const gameContainer = document.querySelector('.game-container');
                    const loadingScreen = document.getElementById('loadingScreen');

                    if (gameContainer) gameContainer.classList.add('loaded');
                    if (loadingScreen) {
                        loadingScreen.classList.add('hidden');
                        // Remove from DOM after transition
                        setTimeout(() => {
                            loadingScreen.remove();
                        }, 500);
                    }
                }, 100);

                // Cards drawn from deck load dynamically via preloadCardOnDraw()
            } catch (error) {
                console.error('Error initializing game:', error);
                // Hide loading screen even on error
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = '<div style="color: white; font-size: 24px;">Error loading game. Please refresh the page.</div>';
                }
            }
        }

        initialize();
    </script>
</body>
</html>
