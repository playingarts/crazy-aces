import { Card } from './models/Card.js';
import { Deck } from './models/Deck.js';

// ============================================================================
// CONFIGURATION CONSTANTS
// ============================================================================
const CONFIG = {
    GAME: {
        INITIAL_HAND_SIZE: 7,
        NUM_JOKERS: 2
    },
    ANIMATION: {
        CARD_DROP_DURATION: 400,        // Duration of card drop animation
        CARD_FLY_DURATION: 250,         // Duration of card flying out
        CARD_SHRINK_DURATION: 250,      // Duration of card shrinking
        HINT_SHAKE_DURATION: 600,       // Duration of hint shake animation
        HAND_RESIZE_DURATION: 500       // Duration of hand resize transition
    },
    TIMING: {
        COMPUTER_TURN_DELAY: 800,       // Delay before computer plays
        HINT_INITIAL_DELAY: 5000,       // Initial delay before first hint
        HINT_REPEAT_DELAY: 5000,        // Delay between hint repetitions
        STATUS_MESSAGE_SHORT: 1500,     // Short status message duration
        STATUS_MESSAGE_LONG: 2000,      // Long status message duration
        DRAW_MESSAGE_DELAY: 1200,       // Delay for draw message
        ANIMATION_DELAY: 400,           // General animation delay
        GAME_END_DELAY: 500             // Delay before showing game over
    },
    URLS: {
        BASE_IMAGE: 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/',
        CARD_INFO_BASE: 'https://playingarts.com/one/',
        BACKSIDE_IMAGE: 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/_backside-evgeny-kiselev.jpg?2'
    }
};

// ============================================================================
// EMAIL & DISCOUNT CONFIGURATION
// ============================================================================

/*
 * EMAILJS SETUP INSTRUCTIONS:
 * 1. Go to https://www.emailjs.com/ and create a free account
 * 2. Add an email service (Gmail, Outlook, etc.)
 * 3. Create 3 email templates with these names:
 *    - template_5percent  (for 5% discount)
 *    - template_10percent (for 10% discount)
 *    - template_15percent (for 15% discount)
 * 4. In each template, use these variables:
 *    - {{to_email}} - recipient email
 *    - {{discount_code}} - the discount code
 *    - {{discount_percent}} - the percentage
 * 5. Copy your Service ID, Template IDs, and Public Key below
 */

const EMAIL_CONFIG = {
    SERVICE_ID: 'service_ev80is9',           // Your EmailJS service ID
    PUBLIC_KEY: 'nygYALzXMsCwmblfZ',         // Your EmailJS public key
    TEMPLATES: {
        5: 'template_t0u5gkf',               // 5% discount template
        10: 'template_t0u5gkf',              // 10% discount template
        15: 'template_t0u5gkf'               // 15% discount template
    },
    DISCOUNT_CODES: {
        5: 'A2F05DZGAME',
        10: 'VPQ10VMGAME',
        15: 'N2V15XWGAME'
    }
};

// ============================================================================
// CARD DATA
// ============================================================================
const cardData = {
    '2♠': { artist: 'Mattias Adolfsson' }, '3♠': { artist: 'Teagan White' },
    '4♠': { artist: 'Serial Cut™' }, '5♠': { artist: 'Musketon' },
    '6♠': { artist: 'Fernando Volken Togni' }, '7♠': { artist: 'Muxxi' },
    '8♠': { artist: 'Gary Fernández' }, '9♠': { artist: 'Anton Repponen' },
    '10♠': { artist: 'Bicicleta Sem Freio' }, 'J♠': { artist: 'Seb Niark1' },
    'Q♠': { artist: 'David Mack' }, 'K♠': { artist: 'Yulia Brodskaya' },
    'A♠': { artist: 'Iain Macarthur' },

    '2♥': { artist: 'Peter Tarka' }, '3♥': { artist: 'Mercedes deBellard' },
    '4♥': { artist: 'Ruben Ireland' }, '5♥': { artist: 'Aitch' },
    '6♥': { artist: 'Javier Medellin Puyou' }, '7♥': { artist: 'Felix LaFlamme' },
    '8♥': { artist: 'Raul Urias' }, '9♥': { artist: 'Carlos Lerma' },
    '10♥': { artist: 'Caramelaw' }, 'J♥': { artist: 'Steve Simpson' },
    'Q♥': { artist: 'Conrad Roset' }, 'K♥': { artist: 'Sara Blake' },
    'A♥': { artist: 'Mr. Kone' },

    '2♦': { artist: 'Yema Yema' }, '3♦': { artist: 'Carne Griffiths' },
    '4♦': { artist: 'Peter Olschinsky' }, '5♦': { artist: 'Fab Ciraolo' },
    '6♦': { artist: 'VASAVA' }, '7♦': { artist: 'Matt W. Moore' },
    '8♦': { artist: 'Jthree Concepts' }, '9♦': { artist: 'Pirecco' },
    '10♦': { artist: 'Lei Melendres' }, 'J♦': { artist: 'Newfren' },
    'Q♦': { artist: 'agnes-cecile' }, 'K♦': { artist: 'Saturno (THE CREATTER)' },
    'A♦': { artist: 'Jordan Debney' },

    '2♣': { artist: 'Tang Yau Hoong' }, '3♣': { artist: 'Fernando Chamarelli' },
    '4♣': { artist: 'MUTI' }, '5♣': { artist: 'Valerie Ann Chua' },
    '6♣': { artist: 'Tobias van Schneider' }, '7♣': { artist: 'Krzysztof CHKN Nowak' },
    '8♣': { artist: 'El Grand Chamaco' }, '9♣': { artist: 'Chuck Anderson' },
    '10♣': { artist: 'Hey' }, 'J♣': { artist: 'Bakea' },
    'Q♣': { artist: 'Ise Ananphada' }, 'K♣': { artist: 'James White' },
    'A♣': { artist: 'Andreas Preis' },

    'JOKER_1': { artist: 'Mike Friedrich' },
    'JOKER_2': { artist: 'Joshua Davis' }
};

const suits = ['♠', '♥', '♦', '♣'];
const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

let deck = [];
let playerHand = [];
let computerHand = [];
let discardPile = [];
let currentSuit = null;
let currentRank = null;
let gameOver = false;
let pendingEightCard = null;
let isComputerTurn = false;
let isFirstMove = true;
let suitWasChanged = false;
let isDrawing = false; // Prevent multiple simultaneous draws
let jokerWasPlayed = false; // Track if joker was just played
let hintTimeout = null;
let winStreak = 0; // Track consecutive wins
let isFirstGame = true; // Track if this is the first game after page load
let playerHasActed = false; // Track if player has made any action yet
let discountClaimed = false; // Track if player has already claimed a discount

// ============================================================================
// TIMEOUT MANAGEMENT - Prevent memory leaks
// ============================================================================
let activeTimeouts = new Set();

/**
 * Create a tracked timeout that will be automatically cleaned up
 * @param {Function} callback - Function to execute
 * @param {number} delay - Delay in milliseconds
 * @returns {number} Timeout ID
 */
function createTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
        activeTimeouts.delete(timeoutId);
        callback();
    }, delay);
    activeTimeouts.add(timeoutId);
    return timeoutId;
}

/**
 * Clear a specific timeout
 * @param {number} timeoutId - The timeout ID to clear
 */
function clearTrackedTimeout(timeoutId) {
    if (timeoutId) {
        clearTimeout(timeoutId);
        activeTimeouts.delete(timeoutId);
    }
}

/**
 * Clear all active timeouts
 */
function clearAllTimeouts() {
    activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    activeTimeouts.clear();
    if (hintTimeout) {
        clearTimeout(hintTimeout);
        hintTimeout = null;
    }
}

// ============================================================================
// GAME LOGIC
// ============================================================================

// Card and Deck functionality now provided by imported classes

// Card image URLs from Playing Arts deck
const cardImages = {
    '2♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-clubs-tang-yau-hoong.jpg?2',
    '2♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-diamonds-yemayema.jpg?2',
    '2♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-hearts-peter-tarka.jpg?2',
    '2♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/2-of-spades-mattias-adolfsson.jpg?2',
    '3♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-clubs-fernando-chamarelli.jpg?2',
    '3♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-diamonds-carne-griffiths.jpg?2',
    '3♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-hearts-mercedes-debellard.jpg?2',
    '3♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/3-of-spades-teagan-white.jpg?2',
    '4♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-clubs-muti.jpg?2',
    '4♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-diamonds-peter-olschinsky.jpg?2',
    '4♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-hearts-ruben-ireland.jpg?2',
    '4♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/4-of-spades-serial-cut.jpg?2',
    '5♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-clubs-valerie-ann-chua.jpg?2',
    '5♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-diamonds-fab-ciraolo.jpg?2',
    '5♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-hearts-aitch.jpg?2',
    '5♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/5-of-spades-musketon.jpg?2',
    '6♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-clubs-tobias-van-schneider.jpg?2',
    '6♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-diamonds-vasava.jpg?2',
    '6♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-hearts-javier-medellin-puyou.jpg?2',
    '6♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/6-of-spades-fernando-volken-togni.jpg?2',
    '7♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-clubs-krzysztof-nowak.jpg?2',
    '7♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-diamonds-matt-w-moore.jpg?2',
    '7♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-hearts-felix-laflamme.jpg?2',
    '7♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/7-of-spades-muxxi.jpg?2',
    '8♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-clubs-el-grand-chamaco.jpg?2',
    '8♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-diamonds-jthree-concepts.jpg?2',
    '8♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-hearts-raul-urias.jpg?2',
    '8♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/8-of-spades-gary-fernandez.jpg?2',
    '9♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-clubs-chuck-anderson.jpg?2',
    '9♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-diamonds-pirecco.jpg?2',
    '9♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-hearts-carlos-lerma.jpg?2',
    '9♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/9-of-spades-anton-repponen.jpg?2',
    '10♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-clubs-hey.jpg?2',
    '10♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-diamonds-lei-melendres.jpg?2',
    '10♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-hearts-caramelaw.jpg?2',
    '10♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/10-of-spades-bicicleta-sem-freio.jpg?2',
    'J♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-clubs-bakea.jpg?2',
    'J♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-diamonds-newfren.jpg?2',
    'J♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-hearts-steve-simpson.jpg?2',
    'J♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/jack-of-spades-seb-niark1.jpg?2',
    'Q♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-clubs-ise-ananphada.jpg?2',
    'Q♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-diamonds-agnes-cecile.jpg?2',
    'Q♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-hearts-conrad-roset.jpg?2',
    'Q♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/queen-of-spades-david-mack.jpg?2',
    'K♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-clubs-james-white.jpg?2',
    'K♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-diamonds-saturno-the-creatter.jpg?2',
    'K♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-hearts-sara-blake.jpg?2',
    'K♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/king-of-spades-yulia-brodskaya.jpg?2',
    'A♣': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-clubs-andreas-preis.jpg?2',
    'A♦': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-diamonds-jordan-debney.jpg?2',
    'A♥': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-hearts-mr-kone.jpg?2',
    'A♠': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/ace-of-spades-iain-macarthur.jpg?2',
    'JOKER': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/joker-mike-friedrich.jpg?2',
    'JOKER_2': 'https://s3.amazonaws.com/img.playingarts.com/one-small-hd/joker-joshua-davis.jpg?2'
};

/**
 * Get the image URL for a card
 * @param {Object} card - The card object
 * @returns {string} Image URL
 */
function getCardImageUrl(card) {
    if (card.isJoker) {
        return card.artist === 'Mike Friedrich' ? cardImages['JOKER'] : cardImages['JOKER_2'];
    }
    const key = card.rank + card.suit;
    return cardImages[key] || '';
}

/**
 * Get the artist page URL for a card
 * @param {Object} card - The card object
 * @returns {string} Artist page URL
 */
function getCardUrl(card) {
    // Map artist names to URL slugs
    const artistSlugs = {
        'Mattias Adolfsson': 'mattias-adolfsson',
        'Teagan White': 'teagan-white',
        'Serial Cut™': 'serial-cut',
        'Musketon': 'musketon',
        'Fernando Volken Togni': 'fernando-volken-togni',
        'Muxxi': 'muxxi',
        'Gary Fernández': 'gary-fernández',
        'Anton Repponen': 'anton-repponen',
        'Bicicleta Sem Freio': 'bicicleta-sem-freio',
        'Seb Niark1': 'seb-niark1',
        'David Mack': 'david-mack',
        'Yulia Brodskaya': 'yulia-brodskaya',
        'Iain Macarthur': 'iain-macarthur',
        'Peter Tarka': 'peter-tarka',
        'Mercedes deBellard': 'mercedes-debellard',
        'Ruben Ireland': 'ruben-ireland',
        'Aitch': 'aitch',
        'Javier Medellin Puyou': 'jilipollo',
        'Felix LaFlamme': 'felix-laflamme',
        'Raul Urias': 'raul-urias',
        'Carlos Lerma': 'carlos-lerma',
        'Caramelaw': 'caramelaw',
        'Steve Simpson': 'steve-simpson',
        'Conrad Roset': 'conrad-roset',
        'Sara Blake': 'sara-blake',
        'Mr. Kone': 'mr-kone',
        'Yema Yema': 'yema-yema',
        'Carne Griffiths': 'carne-griffiths',
        'Peter Olschinsky': 'peter-olschinsky',
        'Fab Ciraolo': 'fab-ciraolo',
        'VASAVA': 'vasava',
        'Matt W. Moore': 'matt-w.-moore',
        'Jthree Concepts': 'jthree-concepts',
        'Pirecco': 'pirecco',
        'Lei Melendres': 'lei-melendres',
        'Newfren': 'newfren',
        'agnes-cecile': 'agnes-cecile',
        'Saturno (THE CREATTER)': 'saturno',
        'Jordan Debney': 'jordan-debney',
        'Tang Yau Hoong': 'tang-yau-hoong',
        'Fernando Chamarelli': 'fernando-chamarelli',
        'MUTI': 'muti',
        'Valerie Ann Chua': 'valerie-ann-chua',
        'Tobias van Schneider': 'tobias-van-schneider',
        'Krzysztof CHKN Nowak': 'krzysztof-chkn-nowak',
        'El Grand Chamaco': 'el-grand-chamaco',
        'Chuck Anderson': 'chuck-anderson',
        'Hey': 'hey',
        'Bakea': 'bakea',
        'Ise Ananphada': 'ise-ananphada',
        'James White': 'james-white',
        'Andreas Preis': 'andreas-preis',
        'Mike Friedrich': 'mike-friedrich',
        'Joshua Davis': 'joshua-davis'
    };

    const slug = artistSlugs[card.artist];
    if (slug) {
        return `https://playingarts.com/one/${slug}`;
    }

    return 'https://playingarts.com/one';
}

/**
 * Get CSS class name for a suit
 * @param {string} suit - Card suit emoji
 * @returns {string} CSS class name
 */
function getSuitClass(suit) {
    const suitMap = { '♠': 'spades', '♥': 'hearts', '♦': 'diamonds', '♣': 'clubs', 'joker': 'joker' };
    return suitMap[suit] || '';
}

/**
 * Initialize a new game
 * @async
 * @returns {Promise<void>}
 */
async function initGame() {
    try {
        // Clear all existing timeouts to prevent memory leaks
        clearAllTimeouts();

        deck = new Deck().shuffle().cards;
        playerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);
        computerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);

        // First discard card (not Ace or joker)
        let firstCard;
        do {
            firstCard = deck.shift();
        } while (firstCard.isAce || firstCard.isJoker);

        discardPile = [firstCard];
        currentSuit = firstCard.suit;
        currentRank = firstCard.rank;

        // Ensure player has at least one playable card
        const hasPlayableCard = playerHand.some(card =>
            card.isJoker || card.isAce || card.suit === currentSuit || card.rank === currentRank
        );

        if (!hasPlayableCard) {
            // Find a matching card in the deck and swap with a random card in player's hand
            const matchingCardIndex = deck.findIndex(card =>
                card.suit === currentSuit || card.rank === currentRank
            );
            if (matchingCardIndex !== -1) {
                const matchingCard = deck.splice(matchingCardIndex, 1)[0];
                const randomIndex = Math.floor(Math.random() * playerHand.length);
                deck.push(playerHand[randomIndex]);
                playerHand[randomIndex] = matchingCard;
            }
        }

        gameOver = false;
        pendingEightCard = null;
        isComputerTurn = false;
        isFirstMove = true;
        suitWasChanged = false;
        isDrawing = false;
        jokerWasPlayed = false;
        playerHasActed = false;

        // Clear any existing hint timeout
        if (hintTimeout) {
            clearTimeout(hintTimeout);
            hintTimeout = null;
        }

        // Preload hand images and table card
        updateStatus('Loading cards...');
        const tableCardUrl = getCardImageUrl(firstCard);
        if (tableCardUrl) {
            await preloadImage(tableCardUrl);
        }
        await preloadHandImages();

        // Show both player and computer hands - reset opacity
        const opponentHand = document.getElementById('opponentHandPreview');
        const playerHandContainer = document.querySelector('.player-hand');
        const playerHandSection = document.querySelector('.player-hand-section');
        if (opponentHand) {
            opponentHand.style.display = 'flex';
            opponentHand.style.visibility = 'visible';
            opponentHand.style.opacity = '1';
        }
        if (playerHandContainer) {
            playerHandContainer.style.display = 'block';
            playerHandContainer.style.visibility = 'visible';
            playerHandContainer.style.opacity = '1';
        }
        if (playerHandSection) {
            playerHandSection.style.opacity = '1';
        }

        document.getElementById('gameOver').classList.remove('show');
        document.getElementById('gameOverOverlay').classList.remove('show');

        // Reset discount UI elements to default state
        const playMoreBtnSmall = document.getElementById('playMoreBtnSmall');
        const discountButtonsContainer = document.getElementById('discountButtonsContainer');
        const discountInfo = document.getElementById('discountInfo');
        if (playMoreBtnSmall) playMoreBtnSmall.style.display = 'block';
        if (discountButtonsContainer) discountButtonsContainer.style.display = 'flex';
        if (discountInfo) discountInfo.style.marginBottom = '20px';

        updateStatus('Play a card matching the table card\'s suit or rank');
        updateDisplay();

        // Start hint timer only on first game after page load
        if (isFirstGame) {
            hintTimeout = setTimeout(showPlayableCardHint, CONFIG.TIMING.HINT_INITIAL_DELAY);
        }
    } catch (error) {
        console.error('Error initializing game:', error);
        updateStatus('Error starting game. Please refresh the page.');
    }
}

/**
 * Wrapper functions for onclick handlers to handle async operations
 * @async
 * @returns {Promise<void>}
 */
async function handlePlayAgain() {
    try {
        await initGame();
    } catch (error) {
        console.error('Error restarting game:', error);
        updateStatus('Error restarting game. Please refresh the page.');
    }
}

/**
 * Wrapper function for draw card action
 * @async
 * @returns {Promise<void>}
 */
async function handleDrawCard() {
    try {
        await drawCard();
    } catch (error) {
        console.error('Error drawing card:', error);
        updateStatus('Error drawing card. Please try again.');
        isDrawing = false;
    }
}

function showPlayableCardHint() {
    if (gameOver || isComputerTurn || playerHasActed) {
        return;
    }

    // Find all playable cards
    const handEl = document.getElementById('playerHand');
    const cardElements = handEl.querySelectorAll('.hand-card');

    cardElements.forEach((cardEl, visualIndex) => {
        const cardIndex = parseInt(cardEl.dataset.cardIndex);
        const card = playerHand[cardIndex];

        if (card && canPlayCard(card)) {
            // Add shake animation
            cardEl.classList.add('hint-shake');

            // Remove animation class after it completes
            setTimeout(() => {
                cardEl.classList.remove('hint-shake');
            }, 600);
        }
    });

    // Schedule next hint in 5 seconds
    hintTimeout = setTimeout(showPlayableCardHint, 5000);
}

function updateDisplay(animate = true, animateFrom = 'top') {
    renderOpponentHand();
    renderTopCard(animate, animateFrom);
    renderPlayerHand();
}

function renderOpponentHand() {
    const container = document.getElementById('opponentHandPreview');
    container.innerHTML = '';

    for (let i = 0; i < computerHand.length; i++) {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back-small';
        container.appendChild(cardBack);
    }
}

/**
 * Render the top card on the discard pile
 * @param {boolean} animate - Whether to animate the card
 * @param {string} animateFrom - Direction to animate from ('top' or 'bottom')
 */
function renderTopCard(animate = true, animateFrom = 'top') {
    const topCardEl = document.getElementById('topCard');
    const card = discardPile[discardPile.length - 1];
    const imageUrl = getCardImageUrl(card);

    // First card is straight (0°), subsequent cards have slight rotation (-3 to 3 degrees)
    const isFirstCard = discardPile.length === 1;
    const rotation = isFirstCard ? 0 : (Math.random() - 0.5) * 6;

    // Only add animation class if animate is true, with direction
    const animationClass = animate ? `card card-animating-from-${animateFrom}` : 'card';
    topCardEl.className = animationClass;
    topCardEl.style.backgroundImage = `url('${imageUrl}')`;
    topCardEl.style.setProperty('--rotation', `${rotation}deg`);
    topCardEl.style.transform = `rotate(${rotation}deg)`;

    // Remove animation class after animation completes
    if (animate) {
        setTimeout(() => {
            topCardEl.classList.remove(`card-animating-from-${animateFrom}`);
        }, 400);
    }
    
    // Render previous cards stack (last 3 cards before current)
    const stackEl = document.getElementById('cardStack');
    stackEl.innerHTML = '';
    
    const stackCount = Math.min(3, discardPile.length - 1);
    for (let i = 1; i <= stackCount; i++) {
        const prevCard = discardPile[discardPile.length - 1 - i];
        const prevImageUrl = getCardImageUrl(prevCard);
        const stackCard = document.createElement('div');
        stackCard.className = 'card';
        stackCard.style.backgroundImage = `url('${prevImageUrl}')`;
        stackCard.style.position = 'absolute';
        stackCard.style.zIndex = -i;
        
        // Slight offset and rotation for stacked cards (-3 to 3 degrees)
        const stackRotation = (Math.random() - 0.5) * 6;
        stackCard.style.transform = `translate(${i * -3}px, ${i * 2}px) rotate(${stackRotation}deg)`;
        stackCard.style.opacity = 0.3;
        
        stackEl.appendChild(stackCard);
    }
    
    // If suit was changed (Ace/Joker played and suit selected), show the NEW suit
    if (suitWasChanged && (card.isJoker || card.isAce)) {
        topCardEl.innerHTML = `
            <div class="card-info">
                <span class="info-suit">${currentSuit}</span>
            </div>
        `;
    } else if (card.isJoker) {
        // Show JOKER text below image (before suit is chosen)
        topCardEl.innerHTML = `
            <div class="card-info">
                <span class="info-joker">JOKER</span>
            </div>
            <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
        `;
        
        // Add animation class
        topCardEl.classList.add('wild-card-played');
        setTimeout(() => {
            topCardEl.classList.remove('wild-card-played');
        }, 1000);
    } else if (card.isAce) {
        // Show Ace rank and suit below image (before suit is chosen)
        topCardEl.innerHTML = `
            <div class="card-info">
                <span class="info-rank">${card.rank}</span>
                <span class="info-suit">${card.suit}</span>
            </div>
            <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
        `;
        
        // Add animation class
        topCardEl.classList.add('wild-card-played');
        setTimeout(() => {
            topCardEl.classList.remove('wild-card-played');
        }, 1000);
    } else {
        // Show rank and suit below image for regular cards
        topCardEl.innerHTML = `
            <div class="card-info">
                <span class="info-rank">${card.rank}</span>
                <span class="info-suit">${card.suit}</span>
            </div>
            <div class="card-artist"><a href="${getCardUrl(card)}" target="_blank">${card.artist}</a></div>
        `;
    }
}

/**
 * Drag and drop handlers
 */
let draggedCardIndex = null;
let draggedCardElement = null;
let touchStartY = 0;
let touchStartX = 0;
let isDragging = false;
let cardOffsetX = 0;
let cardOffsetY = 0;

function handleDragStart(e, index) {
    draggedCardIndex = index;
    e.target.style.opacity = '0.5';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target.innerHTML);
}

function handleDragEnd(e) {
    e.target.style.opacity = '1';
    draggedCardIndex = null;
}

function handleTouchStart(e, index) {
    const touch = e.touches[0];
    const target = e.currentTarget;
    const rect = target.getBoundingClientRect();

    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    draggedCardIndex = index;
    draggedCardElement = target;
    isDragging = false;

    // Calculate offset from touch point to card center
    cardOffsetX = touch.clientX - (rect.left + rect.width / 2);
    cardOffsetY = touch.clientY - (rect.top + rect.height / 2);
}

function handleTouchMove(e) {
    if (draggedCardIndex === null || !draggedCardElement) return;

    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - touchStartX);
    const deltaY = Math.abs(touch.clientY - touchStartY);

    // Start dragging if moved more than 10px
    if (deltaX > 10 || deltaY > 10) {
        if (!isDragging) {
            isDragging = true;
            // Make card follow finger
            draggedCardElement.style.position = 'fixed';
            draggedCardElement.style.zIndex = '1000';
            draggedCardElement.style.opacity = '0.8';
            draggedCardElement.style.pointerEvents = 'none';
            draggedCardElement.style.transition = 'none';
        }

        e.preventDefault(); // Prevent scrolling while dragging

        // Move card to follow finger
        draggedCardElement.style.left = (touch.clientX - cardOffsetX - draggedCardElement.offsetWidth / 2) + 'px';
        draggedCardElement.style.top = (touch.clientY - cardOffsetY - draggedCardElement.offsetHeight / 2) + 'px';

        // Check if over discard pile
        const discardPileEl = document.getElementById('discardPile');
        if (discardPileEl) {
            const rect = discardPileEl.getBoundingClientRect();
            const isOver = touch.clientX >= rect.left && touch.clientX <= rect.right &&
                           touch.clientY >= rect.top && touch.clientY <= rect.bottom;

            if (isOver && !discardPileEl.classList.contains('drag-over')) {
                discardPileEl.classList.add('drag-over');
            } else if (!isOver && discardPileEl.classList.contains('drag-over')) {
                discardPileEl.classList.remove('drag-over');
            }
        }
    }
}

function handleTouchEnd(e) {
    if (draggedCardIndex === null) return;

    const discardPileEl = document.getElementById('discardPile');
    if (discardPileEl) {
        discardPileEl.classList.remove('drag-over');
    }

    // Reset card styling
    if (draggedCardElement && isDragging) {
        draggedCardElement.style.position = '';
        draggedCardElement.style.left = '';
        draggedCardElement.style.top = '';
        draggedCardElement.style.zIndex = '';
        draggedCardElement.style.opacity = '';
        draggedCardElement.style.pointerEvents = '';
        draggedCardElement.style.transition = '';
    }

    // Only play card if dragged (not just a tap)
    if (isDragging) {
        const touch = e.changedTouches[0];
        if (discardPileEl) {
            const rect = discardPileEl.getBoundingClientRect();
            const isOver = touch.clientX >= rect.left && touch.clientX <= rect.right &&
                           touch.clientY >= rect.top && touch.clientY <= rect.bottom;

            if (isOver) {
                playCard(draggedCardIndex);
            }
        }
    }

    draggedCardIndex = null;
    draggedCardElement = null;
    isDragging = false;
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';

    // Add visual feedback
    const discardPileEl = document.getElementById('discardPile');
    if (discardPileEl && !discardPileEl.classList.contains('drag-over')) {
        discardPileEl.classList.add('drag-over');
    }

    return false;
}

function handleDragLeave(e) {
    const discardPileEl = document.getElementById('discardPile');
    if (discardPileEl) {
        discardPileEl.classList.remove('drag-over');
    }
}

function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    e.preventDefault();

    // Remove visual feedback
    const discardPileEl = document.getElementById('discardPile');
    if (discardPileEl) {
        discardPileEl.classList.remove('drag-over');
    }

    if (draggedCardIndex !== null) {
        playCard(draggedCardIndex);
    }

    return false;
}

/**
 * Render the player's hand to the DOM
 */
function renderPlayerHand() {
    const handEl = document.getElementById('playerHand');
    handEl.innerHTML = '';

    // Separate cards: Jokers first, then Aces, then other cards
    const jokers = playerHand.filter(card => card.isJoker);
    const aces = playerHand.filter(card => card.isAce && !card.isJoker);
    const regularCards = playerHand.filter(card => !card.isAce && !card.isJoker);

    // Render Jokers first (most left)
    jokers.forEach((card) => {
        const actualIndex = playerHand.indexOf(card);
        const cardEl = document.createElement('div');
        cardEl.className = 'hand-card joker-card';
        cardEl.dataset.cardIndex = actualIndex;
        cardEl.innerHTML = `
            <div class="card-rank joker-text">JOKER</div>
        `;

        if (!gameOver) {
            cardEl.onclick = () => playCard(actualIndex);
            cardEl.draggable = true;
            cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
            cardEl.ondragend = handleDragEnd;
            cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
            cardEl.ontouchmove = handleTouchMove;
            cardEl.ontouchend = handleTouchEnd;
        }

        handEl.appendChild(cardEl);
    });

    // Render Aces second
    aces.forEach((card) => {
        const actualIndex = playerHand.indexOf(card);
        const cardEl = document.createElement('div');
        cardEl.className = 'hand-card ace-card';
        cardEl.dataset.cardIndex = actualIndex;
        // Show only "A" for Aces, no suit symbol
        cardEl.innerHTML = `
            <div class="card-rank">${card.rank}</div>
        `;

        if (!gameOver) {
            cardEl.onclick = () => playCard(actualIndex);
            cardEl.draggable = true;
            cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
            cardEl.ondragend = handleDragEnd;
            cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
            cardEl.ontouchmove = handleTouchMove;
            cardEl.ontouchend = handleTouchEnd;
        }

        handEl.appendChild(cardEl);
    });

    // Render regular cards last
    regularCards.forEach((card) => {
        const actualIndex = playerHand.indexOf(card);
        const cardEl = document.createElement('div');
        cardEl.className = 'hand-card';
        cardEl.dataset.cardIndex = actualIndex;

        cardEl.innerHTML = `
            <div class="card-rank">${card.rank}</div>
            <div class="card-suit">${card.suit}</div>
        `;

        if (!gameOver) {
            cardEl.onclick = () => playCard(actualIndex);
            cardEl.draggable = true;
            cardEl.ondragstart = (e) => handleDragStart(e, actualIndex);
            cardEl.ondragend = handleDragEnd;
            cardEl.ontouchstart = (e) => handleTouchStart(e, actualIndex);
            cardEl.ontouchmove = handleTouchMove;
            cardEl.ontouchend = handleTouchEnd;
        }

        handEl.appendChild(cardEl);
    });
}

/**
 * Check if a card can be played on the current card
 * @param {Object} card - The card to check
 * @returns {boolean} True if the card can be played
 */
function canPlayCard(card) {
    if (!card) return false;
    if (card.isJoker) return true;
    if (card.isAce) return true;
    if (jokerWasPlayed) return true; // Any card can be played after joker
    if (card.suit === currentSuit) return true;
    if (card.rank === currentRank) return true;
    return false;
}

/**
 * Play a card from the player's hand
 * @param {number} index - The index of the card in the player's hand
 */
function playCard(index) {
    if (gameOver || isComputerTurn || pendingEightCard) return;

    const card = playerHand[index];

    // Safety check
    if (!card) return;

    // Check if card can be played
    if (!canPlayCard(card)) {
        updateStatus('Cannot play that card');
        setTimeout(() => updateStatus(''), 1500);
        return;
    }

    // LOCK TURN IMMEDIATELY before any other operations
    isComputerTurn = true;

    // Mark that player has acted
    if (!playerHasActed) {
        playerHasActed = true;
        // Clear hint timeout on first action
        if (hintTimeout) {
            clearTimeout(hintTimeout);
            hintTimeout = null;
        }
        // Disable hints for future games
        isFirstGame = false;
    }

    // Clear rules message on first move
    if (isFirstMove) {
        isFirstMove = false;
    }

    // Animate the card flying out FIRST - find the correct card element by its data-card-index
    const handEl = document.getElementById('playerHand');
    const cardElement = handEl.querySelector(`[data-card-index="${index}"]`);
    if (cardElement) {
        cardElement.classList.add('card-flying-out');
    }

    // Immediately remove from array and re-render for smooth hand resize
    playerHand.splice(index, 1);
    discardPile.push(card);
    renderPlayerHand();

    // Card from hand is already preloaded - no need to preload again

    // Reset suit change flag for new card
    suitWasChanged = false;

    if (card.isJoker) {
        // Joker = wild - play any card next to define suit
        jokerWasPlayed = true;
        isComputerTurn = false; // Keep turn unlocked
        updateStatus('You played Joker - play another card to define the suit');
        // Update table card and opponent hand immediately
        renderOpponentHand();
        renderTopCard(true, 'bottom');
        return;
    }

    // Check if this card was played after a Joker
    const wasAfterJoker = jokerWasPlayed;
    if (jokerWasPlayed) {
        jokerWasPlayed = false;
        suitWasChanged = true; // Show that suit was changed by joker
    }

    if (card.isAce) {
        // Ace = change suit
        pendingEightCard = card;
        isComputerTurn = false; // Unlock while waiting for suit selection
        updateStatus('You played Ace - choose a suit');
        updateSuitSelector(); // Update which suits are available
        document.getElementById('suitSelectorOverlay').classList.add('show');
        document.getElementById('suitSelector').classList.add('show');
        return;
    }

    currentSuit = card.suit;
    currentRank = card.rank;

    if (wasAfterJoker) {
        updateStatus(`You played ${card.rank}${card.suit} - suit is now ${card.suit}`);
        setTimeout(() => updateStatus(''), 2000);
    } else {
        updateStatus(`You played ${card.rank}${card.suit}`);
        setTimeout(() => updateStatus(''), 1500);
    }

    // Update table card and opponent hand immediately
    renderOpponentHand();
    renderTopCard(true, 'bottom');

    // Wait for fly-out animation before starting computer turn
    setTimeout(() => {

    if (playerHand.length === 0) {
        // Hide player hand immediately with the card animation
        const playerHandContainer = document.querySelector('.player-hand');
        const playerHandSection = document.querySelector('.player-hand-section');
        if (playerHandContainer) {
            playerHandContainer.style.transition = 'opacity 0.25s ease';
            playerHandContainer.style.opacity = '0';
        }
        // Also hide the section on mobile
        if (playerHandSection && window.innerWidth <= 480) {
            playerHandSection.style.opacity = '0';
        }
        setTimeout(() => {
            endGame('player');
        }, 500);
        return;
    }

    setTimeout(async () => {
        await computerTurn();
    }, CONFIG.TIMING.COMPUTER_TURN_DELAY);
    }, CONFIG.ANIMATION.CARD_FLY_DURATION); // Wait for fly-out animation
}

function chooseSuit(suit) {
    document.getElementById('suitSelectorOverlay').classList.remove('show');
    document.getElementById('suitSelector').classList.remove('show');
    currentSuit = suit;
    currentRank = pendingEightCard.rank;
    
    const wasJoker = pendingEightCard.isJoker;
    
    // Transform the Ace/Joker card in discard pile to show the chosen suit
    if (pendingEightCard.isAce) {
        // Find the last card in discard pile (should be the Ace just played)
        const lastCard = discardPile[discardPile.length - 1];
        lastCard.suit = suit; // Change suit to chosen suit
        lastCard.isAce = false; // No longer wild - it's now a specific Ace
        suitWasChanged = false; // Don't need special rendering
    } else {
        suitWasChanged = true; // Keep flag for Jokers
    }
    
    pendingEightCard = null;

    updateStatus(`You changed suit to ${suit}`);
    setTimeout(() => updateStatus(''), 2000);

    updateDisplay(true, 'bottom');

    if (playerHand.length === 0) {
        setTimeout(() => {
            endGame('player');
        }, 500);
        return;
    }

    // If joker was played, skip computer's turn
    if (!wasJoker) {
        isComputerTurn = true;
        setTimeout(async () => {
            await computerTurn();
        }, 800);
    }
}

function updateSuitSelector() {
    // Check which Aces have been played in the discard pile
    const playedAceSuits = new Set();
    discardPile.forEach(card => {
        if (card.rank === 'A' && !card.isAce) {
            // This is an Ace that has been transformed (suit was chosen)
            playedAceSuits.add(card.suit);
        }
    });
    
    // Enable/disable suit options based on played Aces
    const suitMap = {
        '♠': 'suit-spades',
        '♥': 'suit-hearts',
        '♦': 'suit-diamonds',
        '♣': 'suit-clubs'
    };
    
    Object.entries(suitMap).forEach(([suit, id]) => {
        const element = document.getElementById(id);
        if (playedAceSuits.has(suit)) {
            element.classList.add('disabled');
        } else {
            element.classList.remove('disabled');
        }
    });
}

function closeSuitSelector() {
    // Return the card to player's hand
    if (pendingEightCard) {
        discardPile.pop(); // Remove from discard pile
        playerHand.push(pendingEightCard); // Add back to hand
        pendingEightCard = null;
    }

    isComputerTurn = false; // Unlock turn for player

    document.getElementById('suitSelectorOverlay').classList.remove('show');
    document.getElementById('suitSelector').classList.remove('show');
    updateDisplay();
    updateStatus('Card returned to hand');
    setTimeout(() => updateStatus(''), 1500);
}

/**
 * Draw a card from the deck
 * @async
 * @returns {Promise<void>}
 */
async function drawCard() {
    try {
        // Check all locks including the drawing lock
        if (gameOver || isComputerTurn || pendingEightCard || isDrawing) return;

        // LOCK DRAWING IMMEDIATELY before any other operations
        isDrawing = true;
        isComputerTurn = true;

    // Mark that player has acted
    if (!playerHasActed) {
        playerHasActed = true;
        // Clear hint timeout on first action
        if (hintTimeout) {
            clearTimeout(hintTimeout);
            hintTimeout = null;
        }
        // Disable hints for future games
        isFirstGame = false;
    }

    // Hide deck hint after drawing (always, not just first time)
    const deckHint = document.getElementById('deckHint');
    if (deckHint) {
        deckHint.style.display = 'none';
    }

    // Clear rules message on first move
    if (isFirstMove) {
        isFirstMove = false;
    }

    // Clear joker flag if drawing after joker
    if (jokerWasPlayed) {
        jokerWasPlayed = false;
    }

    if (deck.length === 0) {
        updateStatus('Deck empty - pass turn');
        setTimeout(async () => {
            updateStatus('');
            isDrawing = false; // Unlock drawing
            await computerTurn();
        }, 1500);
        return;
    }

    const card = deck.shift();
    if (!card) {
        // Safety check - deck was empty
        updateStatus('Deck empty - pass turn');
        setTimeout(async () => {
            updateStatus('');
            isDrawing = false; // Unlock drawing
            await computerTurn();
        }, 1500);
        return;
    }

    playerHand.push(card);

    // Preload the drawn card before allowing it to be played
    await preloadCardOnDraw(card);

    animateDeckDraw(); // Animate the deck pile
    updateStatus('You drew a card');
    setTimeout(() => updateStatus(''), 1200);
    updateDisplay(false); // No animation when drawing

    if (!canPlayCard(card)) {
        // Card can't be played, computer's turn
        setTimeout(async () => {
            isDrawing = false; // Unlock drawing before computer turn
            await computerTurn();
        }, 1000);
        } else {
            // Card can be played, unlock turn for player to play it
            isComputerTurn = false;
            isDrawing = false; // Unlock drawing
        }
    } catch (error) {
        console.error('Error drawing card:', error);
        isDrawing = false;
        isComputerTurn = false;
        updateStatus('Error drawing card. Please try again.');
    }
}

/**
 * Computer's turn to play
 * @async
 * @returns {Promise<void>}
 */
async function computerTurn() {
    try {
        if (gameOver) return;

        // Find playable cards
        const playableCards = computerHand.filter(canPlayCard);

        if (playableCards.length === 0) {
            // Must draw
            if (deck.length > 0) {
                const card = deck.shift();
                if (!card) {
                    // Deck empty after shift
                    updateDisplay(false); // No animation
                    isComputerTurn = false;
                    return;
                }
                computerHand.push(card);

                // Preload the drawn card before playing it
                await preloadCardOnDraw(card);

                animateDeckDraw(); // Animate the deck pile
                updateStatus('Computer drew a card');
                setTimeout(() => updateStatus(''), 1200);
                updateDisplay(false); // Update display without animating the face-up card

                if (canPlayCard(card)) {
                    setTimeout(() => {
                        const index = computerHand.indexOf(card);
                        if (index !== -1) {
                            computerPlayCard(index);
                        } else {
                            isComputerTurn = false;
                        }
                    }, 1200);
                } else {
                    setTimeout(() => {
                        isComputerTurn = false;
                    }, 1200);
                }
            } else {
                // Deck empty, computer must pass
                updateStatus('Computer passes');
                setTimeout(() => updateStatus(''), 1500);
                isComputerTurn = false;
            }
            return;
        }

        // Play lowest non-special card, or special if needed
        playableCards.sort((a, b) => {
            if (a.isJoker) return 1;
            if (b.isJoker) return -1;
            if (a.isAce) return 1;
            if (b.isAce) return -1;
            const rankOrder = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank);
        });

        const cardToPlay = playableCards[0];
        const index = computerHand.indexOf(cardToPlay);
    
        if (index !== -1) {
            setTimeout(() => {
                computerPlayCard(index);
            }, CONFIG.TIMING.COMPUTER_TURN_DELAY);
        } else {
            isComputerTurn = false;
        }
    } catch (error) {
        console.error('Error in computer turn:', error);
        isComputerTurn = false;
        updateStatus('Error in computer turn. Please try again.');
    }
}

function computerPlayCard(index) {
    const card = computerHand[index];

    // Animate the card flying out from opponent hand
    const opponentHandEl = document.getElementById('opponentHandPreview');
    const cardElements = opponentHandEl.querySelectorAll('.card-back-small');
    if (cardElements[index]) {
        cardElements[index].classList.add('card-flying-out-opponent');
        // Also set width to 0 with transition for smooth resize
        setTimeout(() => {
            cardElements[index].style.transition = 'all 0.25s ease';
            cardElements[index].style.width = '0';
            cardElements[index].style.marginRight = '0';
            cardElements[index].style.opacity = '0';
        }, 150);
    }

    // Wait for animation before removing card from array
    setTimeout(() => {
        computerHand.splice(index, 1);
        discardPile.push(card);

    // Card from hand is already preloaded - no need to preload again

    if (card.isJoker) {
        // Set flag that joker was played
        jokerWasPlayed = true;
        updateStatus('Computer played Joker');
        setTimeout(() => updateStatus(''), 1500);

        // Update display after Joker
        updateDisplay();

        // Check if game is over
        if (computerHand.length === 0) {
            setTimeout(() => {
                endGame('computer');
            }, 500);
            return;
        }

        // Continue turn - play another card after delay
        setTimeout(() => {
            const playableCards = computerHand.filter(canPlayCard);
            if (playableCards.length > 0) {
                // Choose best card (prefer cards matching most common suit)
                const suitCounts = {};
                computerHand.forEach(c => {
                    if (!c.isJoker && !c.isAce) {
                        suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
                    }
                });
                const bestSuit = Object.keys(suitCounts).sort((a,b) => suitCounts[b] - suitCounts[a])[0];

                // Prefer card with best suit
                let cardToPlay = playableCards.find(c => c.suit === bestSuit) || playableCards[0];
                const cardIndex = computerHand.indexOf(cardToPlay);
                computerPlayCard(cardIndex);
            } else {
                // Can't play, end turn
                jokerWasPlayed = false;
                isComputerTurn = false;
            }
        }, 1500);
        return; // Exit early, turn continues
    } else if (card.isAce) {
        // Choose most common suit in hand
        const suitCounts = {};
        computerHand.forEach(c => {
            if (!c.isJoker && !c.isAce) {
                suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
            }
        });
        const bestSuit = Object.keys(suitCounts).sort((a,b) => suitCounts[b] - suitCounts[a])[0] || suits[0];
        currentSuit = bestSuit;
        currentRank = card.rank;

        // Transform the Ace card to show the chosen suit
        card.suit = bestSuit;
        card.isAce = false; // No longer wild
        suitWasChanged = false;

        updateStatus(`Computer played Ace - changed to ${currentSuit}`);
        setTimeout(() => updateStatus(''), 2500);
    } else {
        // If this card was played after a Joker, clear the flag
        if (jokerWasPlayed) {
            jokerWasPlayed = false;
            suitWasChanged = true;
            updateStatus(`Computer played ${card.rank}${card.suit} after Joker`);
            setTimeout(() => updateStatus(''), 2000);
        } else {
            suitWasChanged = false;
            updateStatus(`Computer played ${card.rank}${card.suit}`);
            setTimeout(() => updateStatus(''), 1500);
        }
        currentSuit = card.suit;
        currentRank = card.rank;
    }

    updateDisplay();

    if (computerHand.length === 0) {
        // Hide computer hand immediately with the card animation
        const opponentHandContainer = document.getElementById('opponentHandPreview');
        if (opponentHandContainer) {
            opponentHandContainer.style.transition = 'opacity 0.25s ease';
            opponentHandContainer.style.opacity = '0';
        }
        setTimeout(() => {
            endGame('computer');
        }, 500);
        return;
    }

        isComputerTurn = false; // Unlock turn for player
    }, CONFIG.ANIMATION_DELAY); // Animation delay - wait for card to fly and resize
}

/**
 * Update status message display
 * @param {string} message - The status message to display
 */
function updateStatus(message) {
    const statusEl = document.getElementById('statusMessage');
    if (message) {
        statusEl.textContent = message;
    } else {
        statusEl.textContent = '';
    }
}

/**
 * Animate the deck pile when a card is drawn
 */
function animateDeckDraw() {
    const deckPile = document.querySelector('.deck-pile');
    deckPile.classList.add('deck-drawing');
    setTimeout(() => {
        deckPile.classList.remove('deck-drawing');
    }, CONFIG.ANIMATION.CARD_DROP_DURATION);
}

/**
 * Get discount based on win streak
 * @returns {number} - Discount percentage
 */
function getDiscount() {
    if (winStreak === 1) return 5;
    if (winStreak === 2) return 10;
    if (winStreak >= 3) return 15;
    return 0;
}

/**
 * End the game and display the result
 * @param {string} winner - 'player' or 'computer'
 */
function endGame(winner) {
    gameOver = true;

    const gameOverEl = document.getElementById('gameOver');
    const resultText = document.getElementById('resultText');
    const discountSection = document.getElementById('discountSection');
    const discountText = document.getElementById('discountText');
    const playMoreBtn = document.getElementById('playMoreBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const emailFormInline = document.getElementById('emailFormInline');
    const claimBtn = document.getElementById('claimBtn');
    const claimPercent = document.getElementById('claimPercent');

    // Hide all elements first
    discountSection.style.display = 'none';
    playMoreBtn.style.display = 'none';
    playAgainBtn.style.display = 'none';
    emailFormInline.style.display = 'none';

    if (winner === 'player') {
        winStreak++;
        const discount = getDiscount();

        resultText.textContent = 'You Win!';
        resultText.className = 'result-text win';

        // Show Play More button right after title
        playMoreBtn.style.display = 'block';

        // Check if discount was already claimed
        if (discountClaimed) {
            // Show message that discount was already claimed
            discountText.innerHTML = `${winStreak} win${winStreak > 1 ? 's' : ''} in a row! <strong>You already claimed your discount!</strong>`;
            document.getElementById('discountButtonsContainer').style.display = 'none';
            document.getElementById('discountInfo').style.marginBottom = '0';
        } else {
            // Show discount section with discount and claim button
            discountText.innerHTML = `${winStreak} win${winStreak > 1 ? 's' : ''} in a row - ${discount}% Discount Unlocked!`;
            claimPercent.textContent = discount;

            // Update "Play to get X%" button visibility and text based on current discount
            const playMoreBtnSmall = document.getElementById('playMoreBtnSmall');
            if (discount >= 15) {
                // At max discount, hide the play more button
                playMoreBtnSmall.style.display = 'none';
            } else {
                // Show button with next discount level
                const nextDiscount = discount === 5 ? 10 : 15;
                document.getElementById('playMorePercent').textContent = nextDiscount;
                playMoreBtnSmall.style.display = 'block';
            }

            document.getElementById('discountButtonsContainer').style.display = 'flex';
            document.getElementById('discountInfo').style.marginBottom = '20px';
        }
        discountSection.style.display = 'block';

        launchConfetti();
    } else {
        winStreak = 0; // Reset streak on loss
        resultText.textContent = 'You Lost!';
        resultText.className = 'result-text lose';

        // Show Play More button right after title
        playMoreBtn.style.display = 'block';

        // Show discount section with "You lost the strike" message
        discountText.innerHTML = `<strong>You lost the streak!</strong>`;
        document.getElementById('discountButtonsContainer').style.display = 'none';
        discountSection.style.display = 'block';
    }

    gameOverEl.classList.add('show');
    document.getElementById('gameOverOverlay').classList.add('show');
}

// ============================================================================
// DISCOUNT EMAIL FUNCTIONS
// ============================================================================

/**
 * Show email form when player clicks "Claim Discount"
 */
function showEmailForm() {
    document.getElementById('discountButtonsContainer').style.display = 'none';
    document.getElementById('emailFormInline').style.display = 'block';
    document.getElementById('emailInput').value = '';
    const emailError = document.getElementById('emailError');
    emailError.textContent = '';
    emailError.classList.remove('show');
    document.getElementById('emailInput').focus();
}

/**
 * Hide email form when player clicks "Cancel"
 */
function hideEmailForm() {
    document.getElementById('emailFormInline').style.display = 'none';
    document.getElementById('discountButtonsContainer').style.display = 'flex';
}

/**
 * Handle "Play to get 10%" button click
 */
async function handlePlayToGet10() {
    await handlePlayAgain();
}

/**
 * Handle "Play for More" button click
 */
function handlePlayMore() {
    const gameOverEl = document.getElementById('gameOver');
    gameOverEl.classList.remove('show');

    // Start a new game while keeping the win streak
    initGame();
}

/**
 * Validate email address format
 * @param {string} email - Email address to validate
 * @returns {boolean} True if valid email format
 */
function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

/**
 * Check if email has already claimed a discount
 * @param {string} email - Email address to check
 * @returns {boolean} True if email has already claimed
 */
function hasEmailClaimed(email) {
    try {
        const claimed = localStorage.getItem('claimedEmails');
        if (!claimed) return false;

        const claimedList = JSON.parse(claimed);
        return claimedList.includes(email.toLowerCase());
    } catch (error) {
        console.error('Error checking claimed emails:', error);
        return false;
    }
}

/**
 * Mark email as having claimed a discount
 * @param {string} email - Email address to mark as claimed
 */
function markEmailAsClaimed(email) {
    try {
        const claimed = localStorage.getItem('claimedEmails');
        const claimedList = claimed ? JSON.parse(claimed) : [];

        claimedList.push(email.toLowerCase());
        localStorage.setItem('claimedEmails', JSON.stringify(claimedList));
    } catch (error) {
        console.error('Error saving claimed email:', error);
    }
}

/**
 * Handle "Send Discount" button click
 */
function handleSendDiscount() {
    const emailInput = document.getElementById('emailInput');
    const emailError = document.getElementById('emailError');
    const email = emailInput.value.trim();

    // Clear previous error
    emailError.textContent = '';
    emailError.classList.remove('show');

    // Validate email
    if (!email) {
        emailError.textContent = 'Please enter your email address';
        emailError.classList.add('show');
        return;
    }

    if (!isValidEmail(email)) {
        emailError.textContent = 'Please enter a valid email address';
        emailError.classList.add('show');
        return;
    }

    if (hasEmailClaimed(email)) {
        emailError.textContent = 'This email has already claimed a discount!';
        emailError.classList.add('show');
        return;
    }

    // Send the email
    sendDiscountEmail(email);
}

/**
 * Send discount email using EmailJS
 * @param {string} email - Recipient email address
 */
async function sendDiscountEmail(email) {
    const discount = getDiscount();
    const discountCode = EMAIL_CONFIG.DISCOUNT_CODES[discount];
    const templateId = EMAIL_CONFIG.TEMPLATES[discount];

    // Show loading state
    const sendBtn = document.querySelector('.send-email-btn');
    const originalText = sendBtn.textContent;
    sendBtn.textContent = 'Sending...';
    sendBtn.disabled = true;

    try {
        // Send email via EmailJS
        const response = await emailjs.send(
            EMAIL_CONFIG.SERVICE_ID,
            templateId,
            {
                to_email: email,
                discount_percent: discount,
                discount_code: discountCode,
                wins_count: winStreak
            },
            EMAIL_CONFIG.PUBLIC_KEY
        );

        console.log('Email sent successfully:', response);

        // Mark email as claimed
        markEmailAsClaimed(email);

        // Hide email form and show success message
        document.getElementById('emailFormInline').innerHTML = `
            <div style="font-size: 15px; color: #10b981; text-align: left; margin-bottom: 15px;">
                ✅ Discount sent! Check your email.
            </div>
        `;

        // Mark discount as claimed and reset win streak
        discountClaimed = true;
        winStreak = 0;

    } catch (error) {
        console.error('Error sending email:', error);

        // Show error message
        const emailError = document.getElementById('emailError');
        emailError.textContent = 'Failed to send email. Please try again or contact support.';
        emailError.classList.add('show');

        // Restore button state
        sendBtn.textContent = originalText;
        sendBtn.disabled = false;
    }
}

function launchConfetti() {
    const container = document.getElementById('confettiContainer');
    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff1493'];
    const confettiCount = 300;

    for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';

            container.appendChild(confetti);

            setTimeout(() => {
                confetti.remove();
            }, 5000);
        }, i * 20);
    }
}

function hideRulesBox() {
    const rulesBox = document.getElementById('rulesBox');
    if (rulesBox) {
        rulesBox.classList.add('hidden');
        // Save to localStorage so it stays hidden on refresh
        localStorage.setItem('rulesBoxDismissed', 'true');
    }
}

// Progressive image preloading system
window.preloadedImages = window.preloadedImages || [];
window.preloadedUrls = window.preloadedUrls || new Set();

// Preload a single image
function preloadImage(url) {
    if (!url || window.preloadedUrls.has(url)) {
        return Promise.resolve(); // Already loaded or invalid
    }

    return new Promise((resolve, reject) => {
        const img = new Image();
        // Remove crossOrigin to avoid CORS issues with caching
        img.loading = "eager";
        img.decoding = "async";

        img.onload = () => {
            window.preloadedUrls.add(url);
            window.preloadedImages.push(img); // Keep reference to prevent garbage collection
            resolve();
        };
        img.onerror = (e) => {
            console.error(`Failed to load: ${url}`, e);
            window.preloadedUrls.add(url); // Mark as attempted to avoid retry loops
            resolve(); // Resolve anyway to not block
        };
        img.src = url;

        // If already cached/loaded immediately, resolve
        if (img.complete && img.naturalWidth > 0) {
            window.preloadedUrls.add(url);
            window.preloadedImages.push(img);
            resolve();
        }
    });
}

/**
 * Preload both player and computer hand cards in background
 * @async
 * @returns {Promise<void>}
 */
async function preloadHandImages() {
    try {
        const urls = [];
        let hasAce = false;

        // Player hand
        playerHand.forEach(card => {
            const url = getCardImageUrl(card);
            if (url) urls.push(url);
            if (card.isAce) hasAce = true;
        });

        // Computer hand
        computerHand.forEach(card => {
            const url = getCardImageUrl(card);
            if (url) urls.push(url);
            if (card.isAce) hasAce = true;
        });

        await Promise.all(urls.map(url => preloadImage(url)));
        // If any hand has an ace, preload all 4 aces
        if (hasAce) {
            await preloadAllAces();
        }
    } catch (error) {
        console.error('Error preloading hand images:', error);
        // Continue anyway - images will load on demand
    }
}

/**
 * Preload all four aces (since aces can change suit)
 * @async
 * @returns {Promise<void>}
 */
async function preloadAllAces() {
    try {
        const aceUrls = [
            cardImages['A♠️'],
            cardImages['A♥️'],
            cardImages['A♦️'],
            cardImages['A♣️']
        ];
        await Promise.all(aceUrls.map(url => preloadImage(url)));
    } catch (error) {
        console.error('Error preloading aces:', error);
        // Continue anyway - images will load on demand
    }
}

/**
 * Preload card when drawn from deck
 * @async
 * @param {Object} card - The card to preload
 * @returns {Promise<void>}
 */
async function preloadCardOnDraw(card) {
    try {
        const url = getCardImageUrl(card);
        if (url) {
            await preloadImage(url);
        }

        // If it's an ace, preload all aces (since ace can change suit)
        if (card.isAce) {
            await preloadAllAces();
        }
    } catch (error) {
        console.error('Error preloading card on draw:', error);
        // Continue anyway - image will load on demand
    }
}

// Initialize - progressive loading
async function initialize() {
    try {
        // Check if rules were previously dismissed
        if (localStorage.getItem('rulesBoxDismissed') === 'true') {
            const rulesBox = document.getElementById('rulesBox');
            if (rulesBox) rulesBox.classList.add('hidden');
        }

        // Initialize game data without displaying
        deck = new Deck().shuffle().cards;
        playerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);
        computerHand = deck.splice(0, CONFIG.GAME.INITIAL_HAND_SIZE);

        // First discard card (not Ace or joker)
        let firstCard;
        do {
            firstCard = deck.shift();
        } while (firstCard.isAce || firstCard.isJoker);

        discardPile = [firstCard];
        currentSuit = firstCard.suit;
        currentRank = firstCard.rank;

        // Load only critical images (backside + table card)
        const tableCardUrl = getCardImageUrl(firstCard);
        const backsideUrl = CONFIG.URLS.BACKSIDE_IMAGE;

        const criticalPromises = [
            preloadImage(backsideUrl),
            tableCardUrl ? preloadImage(tableCardUrl) : Promise.resolve()
        ];

        await Promise.all(criticalPromises);

        updateStatus('Loading cards...');

        // Preload ALL hand cards before displaying game
        await preloadHandImages();

        // Now display the game with everything ready
        gameOver = false;
        pendingEightCard = null;
        isComputerTurn = false;
        isFirstMove = true;
        suitWasChanged = false;
        isDrawing = false;
        jokerWasPlayed = false;
        playerHasActed = false;

        // Show both player and computer hands
        const opponentHand = document.getElementById('opponentHandPreview');
        const playerHandContainer = document.querySelector('.player-hand');
        if (opponentHand) {
            opponentHand.style.display = 'flex';
            opponentHand.style.visibility = 'visible';
        }
        if (playerHandContainer) {
            playerHandContainer.style.display = 'block';
            playerHandContainer.style.visibility = 'visible';
        }

        document.getElementById('gameOver').classList.remove('show');
        document.getElementById('gameOverOverlay').classList.remove('show');
        updateStatus('Play a card matching the table card\'s suit or rank');
        updateDisplay();

        // Initialize drag and drop zone
        const discardPileEl = document.getElementById('discardPile');
        if (discardPileEl) {
            discardPileEl.ondragover = handleDragOver;
            discardPileEl.ondragleave = handleDragLeave;
            discardPileEl.ondrop = handleDrop;
        }

        // Start hint timer only on first game after page load
        if (isFirstGame) {
            hintTimeout = setTimeout(showPlayableCardHint, CONFIG.TIMING.HINT_INITIAL_DELAY);
        }

        // Fade in the game and hide loading screen after everything is loaded
        setTimeout(() => {
            const gameContainer = document.querySelector('.game-container');
            const loadingScreen = document.getElementById('loadingScreen');

            if (gameContainer) gameContainer.classList.add('loaded');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
                // Remove from DOM after transition
                setTimeout(() => {
                    loadingScreen.remove();
                }, 500);
            }
        }, 100);

        // Cards drawn from deck load dynamically via preloadCardOnDraw()
    } catch (error) {
        console.error('Error initializing game:', error);
        // Hide loading screen even on error
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.innerHTML = '<div style="color: white; font-size: 24px;">Error loading game. Please refresh the page.</div>';
        }
    }
}

initialize();

// Export functions to global scope for inline event handlers
window.hideRulesBox = hideRulesBox;
window.handleDrawCard = handleDrawCard;
window.chooseSuit = chooseSuit;
window.handlePlayMore = handlePlayMore;
window.showEmailForm = showEmailForm;
window.handlePlayToGet10 = handlePlayToGet10;
window.handleSendDiscount = handleSendDiscount;
window.hideEmailForm = hideEmailForm;
window.handlePlayAgain = handlePlayAgain;
