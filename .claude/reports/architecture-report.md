# Architecture Report

**Date:** 2025-12-09
**Generated by:** Orchestrator
**Status:** Complete

---

# Architecture Review Report

## Health Score: 7/10

The codebase shows good architectural foundations with clear separation of concerns and dependency injection patterns. However, there are some structural issues that could impact maintainability, particularly around the discount claim flow.

## Problems Found

```
[HIGH] God Object in Game.js
Location: src/js/services/Game.js
Issue: Game class handles too many responsibilities - orchestration, error handling, UI coordination, session management
Fix: Extract orchestration logic into separate GameOrchestrator class

[MEDIUM] Complex State Management 
Location: src/js/services/GameState.js
Issue: Mixed concerns - game state + persistence logic + business rules scattered throughout
Fix: Separate GameState (pure data) from GameStateManager (persistence/validation)

[HIGH] Serverless Function Complexity
Location: api/claim-discount.js
Issue: Single function handling validation, database, email, rate limiting - violates SRP
Fix: Extract into smaller, focused functions with shared utilities

[MEDIUM] Inconsistent Error Handling
Location: Multiple files
Issue: Mix of try/catch, error service, and direct throws
Fix: Standardize on errorService pattern throughout

[LOW] Magic Numbers in State
Location: src/js/services/GameState.js
Issue: Hardcoded values like win streak thresholds, game counts
Fix: Move to config constants
```

## Refactoring Suggestions

### Priority 1: Claim Discount Flow Architecture

**Current Problem**: The serverless function is doing everything in one place, making it hard to test and maintain.

**Before**:
```javascript
// api/claim-discount.js - 200+ lines doing everything
export default async function handler(req, res) {
    // validation
    // rate limiting  
    // database checks
    // email sending
    // response formatting
}
```

**After**:
```javascript
// api/claim-discount.js - Clean orchestrator
import { ClaimDiscountService } from './lib/ClaimDiscountService.js';

export default async function handler(req, res) {
    const service = new ClaimDiscountService({ redis, resend });
    return await service.handleClaim(req, res);
}

// api/lib/ClaimDiscountService.js
export class ClaimDiscountService {
    async handleClaim(req, res) {
        const validation = await this.validateRequest(req);
        if (!validation.valid) return this.errorResponse(res, validation.error);
        
        const claim = await this.processClaim(validation.data);
        return this.successResponse(res, claim);
    }
}
```

### Priority 2: Extract Game Orchestrator

**Before**:
```javascript
// Game.js - Doing too much
export class Game {
    constructor(config, dependencies = {}) {
        // 8 different dependencies
        // Complex initialization logic
    }
    
    async init() {
        // UI updates
        // State management  
        // Error handling
        // Session tracking
    }
}
```

**After**:
```javascript
// GameOrchestrator.js - Focused on coordination
export class GameOrchestrator {
    constructor(game, ui, sessionService) {
        this.game = game;
        this.ui = ui;
        this.sessionService = sessionService;
    }
    
    async startNewGame() {
        await this.ui.showLoading();
        await this.game.initialize();
        await this.sessionService.trackGameStart();
        this.ui.showGame();
    }
}

// Game.js - Pure game logic
export class Game {
    constructor(state, engine) {
        this.state = state;
        this.engine = engine;
    }
    
    async initialize() {
        this.state.reset();
        await this.engine.dealCards();
    }
}
```

### Priority 3: State Management Separation

**Before**:
```javascript
// GameState.js - Mixed concerns
export class GameState {
    constructor() {
        this.winStreak = 0; // persistence
        this.deck = null;   // game data
        // Reset logic mixed with data
    }
    
    reset() {
        // Complex persistence vs game state logic
    }
}
```

**After**:
```javascript
// GameData.js - Pure game state
export class GameData {
    constructor() {
        this.deck = null;
        this.playerHand = [];
        this.gameOver = false;
    }
    
    reset() {
        Object.assign(this, new GameData());
    }
}

// GameStateManager.js - Handles persistence
export class GameStateManager {
    constructor(storage = localStorage) {
        this.storage = storage;
        this.gameData = new GameData();
        this.persistentData = this.loadPersistentData();
    }
    
    loadPersistentData() {
        return {
            winStreak: parseInt(this.storage.getItem('winStreak') || '0'),
            discountClaimed: this.storage.getItem('discountClaimed') === 'true'
        };
    }
}
```

## Quick Wins for UX Implementation

Based on architectural review, here are the prioritized quick wins:

### 1. **Extract Claim Validation Logic** (High Impact, Low Effort)
- Move email validation to separate utility
- Create reusable validation functions
- Makes testing easier and UX improvements faster

### 2. **Centralize Discount Constants** (Medium Impact, Low Effort)
```javascript
// config/discount.js
export const DISCOUNT_CONFIG = {
    BASE_DISCOUNT: 5,        // 5% for playing
    WIN_STREAK_BONUS: 5,     // +5% per win
    MAX_DISCOUNT: 40,        // Cap at 40%
    MIN_GAMES_FOR_BASE: 1    // Games needed for base discount
};
```

### 3. **Create Discount State Manager** (High Impact, Medium Effort)
- Separate discount logic from game state
- Makes claim flow independent of game
- Enables better UX feedback

### 4. **Error Standardization** (Medium Impact, Low Effort)
- Use errorService consistently
- Better error messages for users
- Easier debugging

## Recommended Implementation Order

1. **Week 1**: Extract discount constants and validation utilities
2. **Week 2**: Create ClaimDiscountService class  
3. **Week 3**: Implement discount state manager
4. **Week 4**: Refactor Game orchestration

This approach allows UX improvements to be implemented incrementally while improving the underlying architecture.

---

*Report saved to `.claude/reports/architecture-report.md`*
